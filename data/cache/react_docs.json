{
  "library": "react",
  "base_url": "https://react.dev/",
  "pages": [
    {
      "url": "https://react.dev/",
      "title": "React",
      "content": "ReactThe library for web and native user interfacesLearn ReactAPI ReferenceCreate user interfaces from componentsReact lets you build user interfaces out of individual pieces called components. Create your own React components like Thumbnail, LikeButton, and Video. Then combine them into entire screens, pages, and apps.Video.jsfunction Video({ video }) { return ( div Thumbnail video={video} / a href={video.url} h3{video.title}/h3 p{video.description}/p /a LikeButton video={video} / /div );}My videoVideo descriptionWhether you work on your own or with thousands of other developers, using React feels the same. It is designed to let you seamlessly combine components written by independent people, teams, and organizations.Write components with code and markupReact components are JavaScript functions. Want to show some content conditionally? Use an if statement. Displaying a list? Try array map(). Learning React is learning programming.VideoList.jsfunction VideoList({ videos, emptyHeading }) { const count = videos.length; let heading = emptyHeading; if (count  0) { const noun = count  1 ? 'Videos' : 'Video'; heading = count + ' ' + noun; } return ( section h2{heading}/h2 {videos.map(video = Video key={video.id} video={video} / )} /section );}3 VideosFirst videoVideo descriptionSecond videoVideo descriptionThird videoVideo descriptionThis markup syntax is called JSX. It is a JavaScript syntax extension popularized by React. Putting JSX markup close to related rendering logic makes React components easy to create, maintain, and delete.Add interactivity wherever you need itReact components receive data and return what should appear on the screen. You can pass them new data in response to an interaction, like when the user types into an input. React will then update the screen to match the new data.SearchableVideoList.jsimport { useState } from 'react';function SearchableVideoList({ videos }) { const [searchText, setSearchText] = useState(''); const foundVideos = filterVideos(videos, searchText); return (  SearchInput value={searchText} onChange={newText = setSearchText(newText)} / VideoList videos={foundVideos} emptyHeading={`No matches for {searchText}`} / / );}example.com/videos.htmlReact VideosA brief history of ReactSearch5 VideosReact: The DocumentaryThe origin story of ReactRethinking Best PracticesPete Hunt (2013)Introducing React NativeTom Occhino (2015)Introducing React HooksSophie Alpert and Dan Abramov (2018)Introducing Server ComponentsDan Abramov and Lauren Tan (2020)You dont have to build your whole page in React. Add React to your existing HTML page, and render interactive React components anywhere on it.Add React to your pageGo full-stack with a frameworkReact is a library. It lets you put components together, but it doesnt prescribe how to do routing and data fetching. To build an entire app with React, we recommend a full-stack React framework like Next.js or Remix.confs/[slug].jsimport { db } from './database.js';import { Suspense } from 'react';async function ConferencePage({ slug }) { const conf = await db.Confs.find({ slug }); return ( ConferenceLayout conf={conf} Suspense fallback={TalksLoading /} Talks confId={conf.id} / /Suspense /ConferenceLayout );}async function Talks({ confId }) { const talks = await db.Talks.findAll({ confId }); const videos = talks.map(talk = talk.video); return SearchableVideoList videos={videos} /;}example.com/confs/react-conf-2021React Conf 2021React Conf 2019Search19 VideosReact ConfReact 18 KeynoteThe React TeamReact ConfReact 18 for App DevelopersShruti KapoorReact ConfStreaming Server Rendering with SuspenseShaundai PersonReact ConfThe First React Working GroupAakansha DoshiReact ConfReact Developer ToolingBrian VaughnReact ConfReact without memoXuan Huang (\u9ec4\u7384)React ConfReact Docs KeynoteRachel NaborsReact ConfThings I Learnt from the New React DocsDebbie O'BrienReact ConfLearning in the BrowserSarah RainsbergerReact ConfThe ROI of Designing with ReactLinton YeReact ConfInteractive Playgrounds with ReactDelba de OliveiraReact ConfRe-introducing RelayRobert BalickiReact ConfReact Native DesktopEric Rozell and Steven MoyesReact ConfOn-device Machine Learning for React NativeRoman R\u00e4dleReact ConfReact 18 for External Store LibrariesDaishi KatoReact ConfBuilding Accessible Components with React 18Diego HazReact ConfAccessible Japanese Form Components with ReactTafu NakazakiReact ConfUI Tools for ArtistsLyle TroxellReact ConfHydrogen + React 18Helen LinReact is also an architecture. Frameworks that implement it let you fetch data in asynchronous components that run on the server or even during the build. Read data from a file or a database, and pass it down to your interactive components.Get started with a frameworkUse the best from every platformPeople love web and native apps for different reasons. React lets you build both web apps and native apps using the same skills. It leans upon each platforms unique strengths to let your interfaces feel just right on every platform.example.comStay true to the webPeople expect web app pages to load fast. On the server, React lets you start streaming HTML while youre still fetching data, progressively filling in the remaining content before any JavaScript code loads. On the client, React can use standard web APIs to keep your UI responsive even in the middle of rendering.3:47 PMGo truly nativePeople expect native apps to look and feel like their platform. React Native and Expo let you build apps in React for Android, iOS, and more. They look and feel native because their UIs are truly native. Its not a web viewyour React components render real Android and iOS views provided by the platform.With React, you can be a web and a native developer. Your team can ship to many platforms without sacrificing the user experience. Your organization can bridge the platform silos, and form teams that own entire features end-to-end.Build for native platformsUpgrade when the future is readyReact approaches changes with care. Every React commit is tested on business-critical surfaces with over a billion users. Over 100,000 React components at Meta help validate every migration strategy.The React team is always researching how to improve React. Some research takes years to pay off. React has a high bar for taking a research idea into production. Only proven approaches become a part of React.Read more React newsLatest React NewsView Transitions and ActivityApril 23, 2025React Compiler RCApril 21, 2025Sunsetting Create React AppFebruary 14, 2025React 19December 05, 2024Read more React newsJoin a community of millionsYoure not alone. Two million developers from all over the world visit the React docs every month. React is something that people and teams can agree on.This is why React is more than a library, an architecture, or even an ecosystem. React is a community. Its a place where you can ask for help, find opportunities, and meet new friends. You will meet both developers and designers, beginners and experts, researchers and artists, teachers and students. Our backgrounds may be very different, but React lets us all create user interfaces together.Welcome to the React communityGet StartedCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "function Video({ video }) {  return (    <div>      <Thumbnail video={video} />      <a href={video.url}>        <h3>{video.title}</h3>        <p>{video.description}</p>      </a>      <LikeButton video={video} />    </div>  );}",
        "function Video({ video }) {  return (    <div>      <Thumbnail video={video} />      <a href={video.url}>        <h3>{video.title}</h3>        <p>{video.description}</p>      </a>      <LikeButton video={video} />    </div>  );}",
        "function VideoList({ videos, emptyHeading }) {  const count = videos.length;  let heading = emptyHeading;  if (count > 0) {    const noun = count > 1 ? 'Videos' : 'Video';    heading = count + ' ' + noun;  }  return (    <section>      <h2>{heading}</h2>      {videos.map(video =>        <Video key={video.id} video={video} />      )}    </section>  );}",
        "function VideoList({ videos, emptyHeading }) {  const count = videos.length;  let heading = emptyHeading;  if (count > 0) {    const noun = count > 1 ? 'Videos' : 'Video';    heading = count + ' ' + noun;  }  return (    <section>      <h2>{heading}</h2>      {videos.map(video =>        <Video key={video.id} video={video} />      )}    </section>  );}",
        "import { useState } from 'react';function SearchableVideoList({ videos }) {  const [searchText, setSearchText] = useState('');  const foundVideos = filterVideos(videos, searchText);  return (    <>      <SearchInput        value={searchText}        onChange={newText => setSearchText(newText)} />      <VideoList        videos={foundVideos}        emptyHeading={`No matches for \u201c${searchText}\u201d`} />    </>  );}",
        "import { useState } from 'react';function SearchableVideoList({ videos }) {  const [searchText, setSearchText] = useState('');  const foundVideos = filterVideos(videos, searchText);  return (    <>      <SearchInput        value={searchText}        onChange={newText => setSearchText(newText)} />      <VideoList        videos={foundVideos}        emptyHeading={`No matches for \u201c${searchText}\u201d`} />    </>  );}",
        "import { db } from './database.js';import { Suspense } from 'react';async function ConferencePage({ slug }) {  const conf = await db.Confs.find({ slug });  return (    <ConferenceLayout conf={conf}>      <Suspense fallback={<TalksLoading />}>        <Talks confId={conf.id} />      </Suspense>    </ConferenceLayout>  );}async function Talks({ confId }) {  const talks = await db.Talks.findAll({ confId });  const videos = talks.map(talk => talk.video);  return <SearchableVideoList videos={videos} />;}",
        "import { db } from './database.js';import { Suspense } from 'react';async function ConferencePage({ slug }) {  const conf = await db.Confs.find({ slug });  return (    <ConferenceLayout conf={conf}>      <Suspense fallback={<TalksLoading />}>        <Talks confId={conf.id} />      </Suspense>    </ConferenceLayout>  );}async function Talks({ confId }) {  const talks = await db.Talks.findAll({ confId });  const videos = talks.map(talk => talk.video);  return <SearchableVideoList videos={videos} />;}"
      ],
      "chunks": [
        {
          "content": "ReactThe library for web and native user interfacesLearn ReactAPI ReferenceCreate user interfaces from componentsReact lets you build user interfaces out of individual pieces called components Create your own React components like Thumbnail, LikeButton, and Video Then combine them into entire screens, pages, and apps Video jsfunction Video({ video }) { return ( div Thumbnail video={video} / a href={video url} h3{video title}/h3 p{video",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "description}/p /a LikeButton video={video} / /div );}My videoVideo descriptionWhether you work on your own or with thousands of other developers, using React feels the same It is designed to let you seamlessly combine components written by independent people, teams, and organizations Write components with code and markupReact components are JavaScript functions Want to show some content conditionally Use an if statement Displaying a list Try array map() Learning React is learning programming",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "VideoList jsfunction VideoList({ videos, emptyHeading }) { const count = videos length; let heading = emptyHeading; if (count  0) { const noun = count  1 'Videos' : 'Video'; heading = count + ' ' + noun; } return ( section h2{heading}/h2 {videos map(video = Video key={video id} video={video} / )} /section );}3 VideosFirst videoVideo descriptionSecond videoVideo descriptionThird videoVideo descriptionThis markup syntax is called JSX It is a JavaScript syntax extension popularized by React",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Putting JSX markup close to related rendering logic makes React components easy to create, maintain, and delete Add interactivity wherever you need itReact components receive data and return what should appear on the screen You can pass them new data in response to an interaction, like when the user types into an input React will then update the screen to match the new data SearchableVideoList",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "jsimport { useState } from 'react';function SearchableVideoList({ videos }) { const [searchText, setSearchText] = useState(''); const foundVideos = filterVideos(videos, searchText); return (  SearchInput value={searchText} onChange={newText = setSearchText(newText)} / VideoList videos={foundVideos} emptyHeading={`No matches for {searchText}`} / / );}example com/videos",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "htmlReact VideosA brief history of ReactSearch5 VideosReact: The DocumentaryThe origin story of ReactRethinking Best PracticesPete Hunt (2013)Introducing React NativeTom Occhino (2015)Introducing React HooksSophie Alpert and Dan Abramov (2018)Introducing Server ComponentsDan Abramov and Lauren Tan (2020)You dont have to build your whole page in React Add React to your existing HTML page, and render interactive React components anywhere on it",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "Add React to your pageGo full-stack with a frameworkReact is a library It lets you put components together, but it doesnt prescribe how to do routing and data fetching To build an entire app with React, we recommend a full-stack React framework like Next js or Remix confs/[slug] jsimport { db } from ' /database js';import { Suspense } from 'react';async function ConferencePage({ slug }) { const conf = await db Confs",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "find({ slug }); return ( ConferenceLayout conf={conf} Suspense fallback={TalksLoading /} Talks confId={conf id} / /Suspense /ConferenceLayout );}async function Talks({ confId }) { const talks = await db Talks findAll({ confId }); const videos = talks map(talk = talk video); return SearchableVideoList videos={videos} /;}example",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "com/confs/react-conf-2021React Conf 2021React Conf 2019Search19 VideosReact ConfReact 18 KeynoteThe React TeamReact ConfReact 18 for App DevelopersShruti KapoorReact ConfStreaming Server Rendering with SuspenseShaundai PersonReact ConfThe First React Working GroupAakansha DoshiReact ConfReact Developer ToolingBrian VaughnReact ConfReact without memoXuan Huang (\u9ec4\u7384)React ConfReact Docs KeynoteRachel NaborsReact ConfThings I Learnt from the New React DocsDebbie O'BrienReact ConfLearning in the BrowserSarah RainsbergerReact ConfThe ROI of Designing with ReactLinton YeReact ConfInteractive Playgrounds with ReactDelba de OliveiraReact ConfRe-introducing RelayRobert BalickiReact ConfReact Native DesktopEric Rozell and Steven MoyesReact ConfOn-device Machine Learning for React NativeRoman R\u00e4dleReact ConfReact 18 for External Store LibrariesDaishi KatoReact ConfBuilding Accessible Components with React 18Diego HazReact ConfAccessible Japanese Form Components with ReactTafu NakazakiReact ConfUI Tools for ArtistsLyle TroxellReact ConfHydrogen + React 18Helen LinReact is also an architecture",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "Frameworks that implement it let you fetch data in asynchronous components that run on the server or even during the build Read data from a file or a database, and pass it down to your interactive components Get started with a frameworkUse the best from every platformPeople love web and native apps for different reasons React lets you build both web apps and native apps using the same skills It leans upon each platforms unique strengths to let your interfaces feel just right on every platform",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "example comStay true to the webPeople expect web app pages to load fast On the server, React lets you start streaming HTML while youre still fetching data, progressively filling in the remaining content before any JavaScript code loads On the client, React can use standard web APIs to keep your UI responsive even in the middle of rendering 3:47 PMGo truly nativePeople expect native apps to look and feel like their platform",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "React Native and Expo let you build apps in React for Android, iOS, and more They look and feel native because their UIs are truly native Its not a web viewyour React components render real Android and iOS views provided by the platform With React, you can be a web and a native developer Your team can ship to many platforms without sacrificing the user experience Your organization can bridge the platform silos, and form teams that own entire features end-to-end",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "Build for native platformsUpgrade when the future is readyReact approaches changes with care Every React commit is tested on business-critical surfaces with over a billion users Over 100,000 React components at Meta help validate every migration strategy The React team is always researching how to improve React Some research takes years to pay off React has a high bar for taking a research idea into production Only proven approaches become a part of React",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Read more React newsLatest React NewsView Transitions and ActivityApril 23, 2025React Compiler RCApril 21, 2025Sunsetting Create React AppFebruary 14, 2025React 19December 05, 2024Read more React newsJoin a community of millionsYoure not alone Two million developers from all over the world visit the React docs every month React is something that people and teams can agree on This is why React is more than a library, an architecture, or even an ecosystem React is a community",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Its a place where you can ask for help, find opportunities, and meet new friends You will meet both developers and designers, beginners and experts, researchers and artists, teachers and students Our backgrounds may be very different, but React lets us all create user interfaces together Welcome to the React communityGet StartedCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/",
          "library": "react",
          "chunk_id": "react_15"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn",
      "title": "Quick Start \u2013 React",
      "content": "Learn ReactQuick StartWelcome to the React documentation! This page will give you an introduction to 80 of the React concepts that you will use on a daily basis. You will learn How to create and nest components How to add markup and styles How to display data How to render conditions and lists How to respond to events and update the screen How to share data between components Creating and nesting components React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page. React components are JavaScript functions that return markup: function MyButton() { return ( buttonI'm a button/button );} Now that youve declared MyButton, you can nest it into another component: export default function MyApp() { return ( div h1Welcome to my app/h1 MyButton / /div );} Notice that MyButton / starts with a capital letter. Thats how you know its a React component. React component names must always start with a capital letter, while HTML tags must be lowercase. Have a look at the result: App.jsApp.js ResetForkfunction MyButton() { return ( button I'm a button /button ); } export default function MyApp() { return ( div h1Welcome to my app/h1 MyButton / /div ); } Show more The export default keywords specify the main component in the file. If youre not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references. Writing markup with JSX The markup syntax youve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box. JSX is stricter than HTML. You have to close tags like br /. Your component also cant return multiple JSX tags. You have to wrap them into a shared parent, like a div.../div or an empty .../ wrapper: function AboutPage() { return (  h1About/h1 pHello there.br /How do you do?/p / );} If you have a lot of HTML to port to JSX, you can use an online converter. Adding styles In React, you specify a CSS class with className. It works the same way as the HTML class attribute: img className=\"avatar\" / Then you write the CSS rules for it in a separate CSS file: /* In your CSS */.avatar { border-radius: 50;} React does not prescribe how you add CSS files. In the simplest case, youll add a link tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project. Displaying data JSX lets you put markup into JavaScript. Curly braces let you escape back into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display user.name: return ( h1 {user.name} /h1); You can also escape into JavaScript from JSX attributes, but you have to use curly braces instead of quotes. For example, className=\"avatar\" passes the \"avatar\" string as the CSS class, but src={user.imageUrl} reads the JavaScript user.imageUrl variable value, and then passes that value as the src attribute: return ( img className=\"avatar\" src={user.imageUrl} /); You can put more complex expressions inside the JSX curly braces too, for example, string concatenation: App.jsApp.js ResetForkconst user = { name: 'Hedy Lamarr', imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg', imageSize: 90, }; export default function Profile() { return (  h1{user.name}/h1 img className=\"avatar\" src={user.imageUrl} alt={'Photo of ' + user.name} style={{ width: user.imageSize, height: user.imageSize }} / / ); } Show more In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. You can use the style attribute when your styles depend on JavaScript variables. Conditional rendering In React, there is no special syntax for writing conditions. Instead, youll use the same techniques as you use when writing regular JavaScript code. For example, you can use an if statement to conditionally include JSX: let content;if (isLoggedIn) { content = AdminPanel /;} else { content = LoginForm /;}return ( div {content} /div); If you prefer more compact code, you can use the conditional ? operator. Unlike if, it works inside JSX: div {isLoggedIn ? ( AdminPanel / ) : ( LoginForm / )}/div When you dont need the else branch, you can also use a shorter logical  syntax: div {isLoggedIn  AdminPanel /}/div All of these approaches also work for conditionally specifying attributes. If youre unfamiliar with some of this JavaScript syntax, you can start by always using if...else. Rendering lists You will rely on JavaScript features like for loop and the array map() function to render lists of components. For example, lets say you have an array of products: const products = [ { title: 'Cabbage', id: 1 }, { title: 'Garlic', id: 2 }, { title: 'Apple', id: 3 },]; Inside your component, use the map() function to transform an array of products into an array of li items: const listItems = products.map(product = li key={product.id} {product.title} /li);return ( ul{listItems}/ul); Notice how li has a key attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items. App.jsApp.js ResetForkconst products = [ { title: 'Cabbage', isFruit: false, id: 1 }, { title: 'Garlic', isFruit: false, id: 2 }, { title: 'Apple', isFruit: true, id: 3 }, ]; export default function ShoppingList() { const listItems = products.map(product = li key={product.id} style={{ color: product.isFruit ? 'magenta' : 'darkgreen' }}  {product.title} /li ); return ( ul{listItems}/ul ); } Show more Responding to events You can respond to events by declaring event handler functions inside your components: function MyButton() { function handleClick() { alert('You clicked me!'); } return ( button onClick={handleClick} Click me /button );} Notice how onClick={handleClick} has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button. Updating the screen Often, youll want your component to remember some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component. First, import useState from React: import { useState } from 'react'; Now you can declare a state variable inside your component: function MyButton() { const [count, setCount] = useState(0); // ... Youll get two things from useState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write [something, setSomething]. The first time the button is displayed, count will be 0 because you passed 0 to useState(). When you want to change state, call setCount() and pass the new value to it. Clicking this button will increment the counter: function MyButton() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} Clicked {count} times /button );} React will call your component function again. This time, count will be 1. Then it will be 2. And so on. If you render the same component multiple times, each will get its own state. Click each button separately: App.jsApp.js ResetForkimport { useState } from 'react'; export default function MyApp() { return ( div h1Counters that update separately/h1 MyButton / MyButton / /div ); } function MyButton() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} Clicked {count} times /button ); } Show more Notice how each button remembers its own count state and doesnt affect other buttons. Using Hooks Functions starting with use are called Hooks. useState is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones. Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there. Sharing data between components In the previous example, each MyButton had its own independent count, and when each button was clicked, only the count for the button clicked changed: Initially, each MyButtons count state is 0The first MyButton updates its count to 1 However, often youll need components to share data and always update together. To make both MyButton components display the same count and update together, you need to move the state from the individual buttons upwards to the closest component containing all of them. In this example, it is MyApp: Initially, MyApps count state is 0 and is passed down to both childrenOn click, MyApp updates its count state to 1 and passes it down to both children Now when you click either button, the count in MyApp will change, which will change both of the counts in MyButton. Heres how you can express this in code. First, move the state up from MyButton into MyApp: export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update separately/h1 MyButton / MyButton / /div );}function MyButton() { // ... we're moving code from here ...} Then, pass the state down from MyApp to each MyButton, together with the shared click handler. You can pass information to MyButton using the JSX curly braces, just like you previously did with built-in tags like img: export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update together/h1 MyButton count={count} onClick={handleClick} / MyButton count={count} onClick={handleClick} / /div );} The information you pass down like this is called props. Now the MyApp component contains the count state and the handleClick event handler, and passes both of them down as props to each of the buttons. Finally, change MyButton to read the props you have passed from its parent component: function MyButton({ count, onClick }) { return ( button onClick={onClick} Clicked {count} times /button );} When you click the button, the onClick handler fires. Each buttons onClick prop was set to the handleClick function inside MyApp, so the code inside of it runs. That code calls setCount(count + 1), incrementing the count state variable. The new count value is passed as a prop to each button, so they all show the new value. This is called lifting state up. By moving state up, youve shared it between components. App.jsApp.js ResetForkimport { useState } from 'react'; export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update together/h1 MyButton count={count} onClick={handleClick} / MyButton count={count} onClick={handleClick} / /div ); } function MyButton({ count, onClick }) { return ( button onClick={onClick} Clicked {count} times /button ); } Show more Next Steps By now, you know the basics of how to write React code! Check out the Tutorial to put them into practice and build your first mini-app with React.NextTutorial: Tic-Tac-ToeCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "function MyButton() {  return (    <button>I'm a button</button>  );}",
        "function MyButton() {  return (    <button>I'm a button</button>  );}",
        "export default function MyApp() {  return (    <div>      <h1>Welcome to my app</h1>      <MyButton />    </div>  );}",
        "export default function MyApp() {  return (    <div>      <h1>Welcome to my app</h1>      <MyButton />    </div>  );}",
        "<MyButton />",
        "function MyButton() {\n  return (\n    <button>\n      I'm a button\n    </button>\n  );\n}\n\nexport default function MyApp() {\n  return (\n    <div>\n      <h1>Welcome to my app</h1>\n      <MyButton />\n    </div>\n  );\n}",
        "export default",
        "<div>...</div>",
        "function AboutPage() {  return (    <>      <h1>About</h1>      <p>Hello there.<br />How do you do?</p>    </>  );}",
        "function AboutPage() {  return (    <>      <h1>About</h1>      <p>Hello there.<br />How do you do?</p>    </>  );}",
        "<img className=\"avatar\" />",
        "<img className=\"avatar\" />",
        "/* In your CSS */.avatar {  border-radius: 50%;}",
        "/* In your CSS */.avatar {  border-radius: 50%;}",
        "return (  <h1>    {user.name}  </h1>);",
        "return (  <h1>    {user.name}  </h1>);",
        "className=\"avatar\"",
        "src={user.imageUrl}",
        "user.imageUrl",
        "return (  <img    className=\"avatar\"    src={user.imageUrl}  />);",
        "return (  <img    className=\"avatar\"    src={user.imageUrl}  />);",
        "const user = {\n  name: 'Hedy Lamarr',\n  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',\n  imageSize: 90,\n};\n\nexport default function Profile() {\n  return (\n    <>\n      <h1>{user.name}</h1>\n      <img\n        className=\"avatar\"\n        src={user.imageUrl}\n        alt={'Photo of ' + user.name}\n        style={{\n          width: user.imageSize,\n          height: user.imageSize\n        }}\n      />\n    </>\n  );\n}",
        "let content;if (isLoggedIn) {  content = <AdminPanel />;} else {  content = <LoginForm />;}return (  <div>    {content}  </div>);",
        "let content;if (isLoggedIn) {  content = <AdminPanel />;} else {  content = <LoginForm />;}return (  <div>    {content}  </div>);",
        "<div>  {isLoggedIn ? (    <AdminPanel />  ) : (    <LoginForm />  )}</div>",
        "<div>  {isLoggedIn ? (    <AdminPanel />  ) : (    <LoginForm />  )}</div>",
        "<div>  {isLoggedIn && <AdminPanel />}</div>",
        "<div>  {isLoggedIn && <AdminPanel />}</div>",
        "const products = [  { title: 'Cabbage', id: 1 },  { title: 'Garlic', id: 2 },  { title: 'Apple', id: 3 },];",
        "const products = [  { title: 'Cabbage', id: 1 },  { title: 'Garlic', id: 2 },  { title: 'Apple', id: 3 },];",
        "const listItems = products.map(product =>  <li key={product.id}>    {product.title}  </li>);return (  <ul>{listItems}</ul>);",
        "const listItems = products.map(product =>  <li key={product.id}>    {product.title}  </li>);return (  <ul>{listItems}</ul>);",
        "const products = [\n  { title: 'Cabbage', isFruit: false, id: 1 },\n  { title: 'Garlic', isFruit: false, id: 2 },\n  { title: 'Apple', isFruit: true, id: 3 },\n];\n\nexport default function ShoppingList() {\n  const listItems = products.map(product =>\n    <li\n      key={product.id}\n      style={{\n        color: product.isFruit ? 'magenta' : 'darkgreen'\n      }}\n    >\n      {product.title}\n    </li>\n  );\n\n  return (\n    <ul>{listItems}</ul>\n  );\n}",
        "function MyButton() {  function handleClick() {    alert('You clicked me!');  }  return (    <button onClick={handleClick}>      Click me    </button>  );}",
        "function MyButton() {  function handleClick() {    alert('You clicked me!');  }  return (    <button onClick={handleClick}>      Click me    </button>  );}",
        "onClick={handleClick}",
        "import { useState } from 'react';",
        "import { useState } from 'react';",
        "function MyButton() {  const [count, setCount] = useState(0);  // ...",
        "function MyButton() {  const [count, setCount] = useState(0);  // ...",
        "[something, setSomething]",
        "function MyButton() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <button onClick={handleClick}>      Clicked {count} times    </button>  );}",
        "function MyButton() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <button onClick={handleClick}>      Clicked {count} times    </button>  );}",
        "import { useState } from 'react';\n\nexport default function MyApp() {\n  return (\n    <div>\n      <h1>Counters that update separately</h1>\n      <MyButton />\n      <MyButton />\n    </div>\n  );\n}\n\nfunction MyButton() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Clicked {count} times\n    </button>\n  );\n}",
        "export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update separately</h1>      <MyButton />      <MyButton />    </div>  );}function MyButton() {  // ... we're moving code from here ...}",
        "export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update separately</h1>      <MyButton />      <MyButton />    </div>  );}function MyButton() {  // ... we're moving code from here ...}",
        "export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update together</h1>      <MyButton count={count} onClick={handleClick} />      <MyButton count={count} onClick={handleClick} />    </div>  );}",
        "export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update together</h1>      <MyButton count={count} onClick={handleClick} />      <MyButton count={count} onClick={handleClick} />    </div>  );}",
        "handleClick",
        "function MyButton({ count, onClick }) {  return (    <button onClick={onClick}>      Clicked {count} times    </button>  );}",
        "function MyButton({ count, onClick }) {  return (    <button onClick={onClick}>      Clicked {count} times    </button>  );}",
        "handleClick",
        "setCount(count + 1)",
        "import { useState } from 'react';\n\nexport default function MyApp() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      <h1>Counters that update together</h1>\n      <MyButton count={count} onClick={handleClick} />\n      <MyButton count={count} onClick={handleClick} />\n    </div>\n  );\n}\n\nfunction MyButton({ count, onClick }) {\n  return (\n    <button onClick={onClick}>\n      Clicked {count} times\n    </button>\n  );\n}"
      ],
      "chunks": [
        {
          "content": "Learn ReactQuick StartWelcome to the React documentation This page will give you an introduction to 80 of the React concepts that you will use on a daily basis You will learn How to create and nest components How to add markup and styles How to display data How to render conditions and lists How to respond to events and update the screen How to share data between components Creating and nesting components React apps are made out of components",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "A component is a piece of the UI (user interface) that has its own logic and appearance A component can be as small as a button, or as large as an entire page React components are JavaScript functions that return markup: function MyButton() { return ( buttonI'm a button/button );} Now that youve declared MyButton, you can nest it into another component: export default function MyApp() { return ( div h1Welcome to my app/h1 MyButton / /div );} Notice that MyButton / starts with a capital letter",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Thats how you know its a React component React component names must always start with a capital letter, while HTML tags must be lowercase Have a look at the result: App jsApp js ResetForkfunction MyButton() { return ( button I'm a button /button ); } export default function MyApp() { return ( div h1Welcome to my app/h1 MyButton / /div ); } Show more The export default keywords specify the main component in the file If youre not familiar with some piece of JavaScript syntax, MDN and javascript",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "info have great references Writing markup with JSX The markup syntax youve seen above is called JSX It is optional, but most React projects use JSX for its convenience All of the tools we recommend for local development support JSX out of the box JSX is stricter than HTML You have to close tags like br / Your component also cant return multiple JSX tags You have to wrap them into a shared parent, like a div /div or an empty / wrapper: function AboutPage() { return (  h1About/h1 pHello there",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "br /How do you do /p / );} If you have a lot of HTML to port to JSX, you can use an online converter Adding styles In React, you specify a CSS class with className It works the same way as the HTML class attribute: img className=\"avatar\" / Then you write the CSS rules for it in a separate CSS file: /* In your CSS */ avatar { border-radius: 50;} React does not prescribe how you add CSS files In the simplest case, youll add a link tag to your HTML",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project Displaying data JSX lets you put markup into JavaScript Curly braces let you escape back into JavaScript so that you can embed some variable from your code and display it to the user For example, this will display user name: return ( h1 {user name} /h1); You can also escape into JavaScript from JSX attributes, but you have to use curly braces instead of quotes",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "For example, className=\"avatar\" passes the \"avatar\" string as the CSS class, but src={user imageUrl} reads the JavaScript user imageUrl variable value, and then passes that value as the src attribute: return ( img className=\"avatar\" src={user imageUrl} /); You can put more complex expressions inside the JSX curly braces too, for example, string concatenation: App jsApp js ResetForkconst user = { name: 'Hedy Lamarr', imageUrl: 'https://i imgur com/yXOvdOSs",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "jpg', imageSize: 90, }; export default function Profile() { return (  h1{user name}/h1 img className=\"avatar\" src={user imageUrl} alt={'Photo of ' + user name} style={{ width: user imageSize, height: user imageSize }} / / ); } Show more In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces You can use the style attribute when your styles depend on JavaScript variables",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "Conditional rendering In React, there is no special syntax for writing conditions Instead, youll use the same techniques as you use when writing regular JavaScript code For example, you can use an if statement to conditionally include JSX: let content;if (isLoggedIn) { content = AdminPanel /;} else { content = LoginForm /;}return ( div {content} /div); If you prefer more compact code, you can use the conditional operator Unlike if, it works inside JSX: div {isLoggedIn",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "( AdminPanel / ) : ( LoginForm / )}/div When you dont need the else branch, you can also use a shorter logical  syntax: div {isLoggedIn  AdminPanel /}/div All of these approaches also work for conditionally specifying attributes If youre unfamiliar with some of this JavaScript syntax, you can start by always using if else Rendering lists You will rely on JavaScript features like for loop and the array map() function to render lists of components",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "For example, lets say you have an array of products: const products = [ { title: 'Cabbage', id: 1 }, { title: 'Garlic', id: 2 }, { title: 'Apple', id: 3 },]; Inside your component, use the map() function to transform an array of products into an array of li items: const listItems = products map(product = li key={product id} {product title} /li);return ( ul{listItems}/ul); Notice how li has a key attribute",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings Usually, a key should be coming from your data, such as a database ID React uses your keys to know what happened if you later insert, delete, or reorder the items App jsApp",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "js ResetForkconst products = [ { title: 'Cabbage', isFruit: false, id: 1 }, { title: 'Garlic', isFruit: false, id: 2 }, { title: 'Apple', isFruit: true, id: 3 }, ]; export default function ShoppingList() { const listItems = products map(product = li key={product id} style={{ color: product isFruit 'magenta' : 'darkgreen' }}  {product",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "title} /li ); return ( ul{listItems}/ul ); } Show more Responding to events You can respond to events by declaring event handler functions inside your components: function MyButton() { function handleClick() { alert('You clicked me '); } return ( button onClick={handleClick} Click me /button );} Notice how onClick={handleClick} has no parentheses at the end Do not call the event handler function: you only need to pass it down React will call your event handler when the user clicks the button",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Updating the screen Often, youll want your component to remember some information and display it For example, maybe you want to count the number of times a button is clicked To do this, add state to your component First, import useState from React: import { useState } from 'react'; Now you can declare a state variable inside your component: function MyButton() { const [count, setCount] = useState(0); //",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "Youll get two things from useState: the current state (count), and the function that lets you update it (setCount) You can give them any names, but the convention is to write [something, setSomething] The first time the button is displayed, count will be 0 because you passed 0 to useState() When you want to change state, call setCount() and pass the new value to it",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "Clicking this button will increment the counter: function MyButton() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} Clicked {count} times /button );} React will call your component function again This time, count will be 1 Then it will be 2 And so on If you render the same component multiple times, each will get its own state Click each button separately: App jsApp",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; export default function MyApp() { return ( div h1Counters that update separately/h1 MyButton / MyButton / /div ); } function MyButton() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} Clicked {count} times /button ); } Show more Notice how each button remembers its own count state and doesnt affect other buttons Using Hooks Functions starting with use are called Hooks",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "useState is a built-in Hook provided by React You can find other built-in Hooks in the API reference You can also write your own Hooks by combining the existing ones Hooks are more restrictive than other functions You can only call Hooks at the top of your components (or other Hooks) If you want to use useState in a condition or a loop, extract a new component and put it there",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "Sharing data between components In the previous example, each MyButton had its own independent count, and when each button was clicked, only the count for the button clicked changed: Initially, each MyButtons count state is 0The first MyButton updates its count to 1 However, often youll need components to share data and always update together",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "To make both MyButton components display the same count and update together, you need to move the state from the individual buttons upwards to the closest component containing all of them In this example, it is MyApp: Initially, MyApps count state is 0 and is passed down to both childrenOn click, MyApp updates its count state to 1 and passes it down to both children Now when you click either button, the count in MyApp will change, which will change both of the counts in MyButton",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "Heres how you can express this in code First, move the state up from MyButton into MyApp: export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update separately/h1 MyButton / MyButton / /div );}function MyButton() { // we're moving code from here } Then, pass the state down from MyApp to each MyButton, together with the shared click handler",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "You can pass information to MyButton using the JSX curly braces, just like you previously did with built-in tags like img: export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update together/h1 MyButton count={count} onClick={handleClick} / MyButton count={count} onClick={handleClick} / /div );} The information you pass down like this is called props",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "Now the MyApp component contains the count state and the handleClick event handler, and passes both of them down as props to each of the buttons Finally, change MyButton to read the props you have passed from its parent component: function MyButton({ count, onClick }) { return ( button onClick={onClick} Clicked {count} times /button );} When you click the button, the onClick handler fires Each buttons onClick prop was set to the handleClick function inside MyApp, so the code inside of it runs",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "That code calls setCount(count + 1), incrementing the count state variable The new count value is passed as a prop to each button, so they all show the new value This is called lifting state up By moving state up, youve shared it between components App jsApp",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; export default function MyApp() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( div h1Counters that update together/h1 MyButton count={count} onClick={handleClick} / MyButton count={count} onClick={handleClick} / /div ); } function MyButton({ count, onClick }) { return ( button onClick={onClick} Clicked {count} times /button ); } Show more Next Steps By now, you know the basics of how to write React code",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "Check out the Tutorial to put them into practice and build your first mini-app with React NextTutorial: Tic-Tac-ToeCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn",
          "library": "react",
          "chunk_id": "react_26"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react",
      "title": "React Reference Overview \u2013 React",
      "content": "API ReferenceReact Reference OverviewThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section. The React reference documentation is broken down into functional subsections: React Programmatic React features: Hooks - Use different React features from your components. Components - Built-in components that you can use in your JSX. APIs - APIs that are useful for defining components. Directives - Provide instructions to bundlers compatible with React Server Components. React DOM React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following: Hooks - Hooks for web applications which run in the browser DOM environment. Components - React supports all of the browser built-in HTML and SVG components. APIs - The react-dom package contains methods supported only in web applications. Client APIs - The react-dom/client APIs let you render React components on the client (in the browser). Server APIs - The react-dom/server APIs let you render React components to HTML on the server. Rules of React React has idioms  or rules  for how to express patterns in a way that is easy to understand and yields high-quality applications: Components and Hooks must be pure  Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly. React calls Components and Hooks  React is responsible for rendering components and hooks when necessary to optimize the user experience. Rules of Hooks  Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. Legacy APIs Legacy APIs - Exported from the react package, but not recommended for use in newly written code. NextHooksCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "react-dom/client",
        "react-dom/server"
      ],
      "chunks": [
        {
          "content": "API ReferenceReact Reference OverviewThis section provides detailed reference documentation for working with React For an introduction to React, please visit the Learn section The React reference documentation is broken down into functional subsections: React Programmatic React features: Hooks - Use different React features from your components Components - Built-in components that you can use in your JSX APIs - APIs that are useful for defining components",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "Directives - Provide instructions to bundlers compatible with React Server Components React DOM React-dom contains features that are only supported for web applications (which run in the browser DOM environment) This section is broken into the following: Hooks - Hooks for web applications which run in the browser DOM environment Components - React supports all of the browser built-in HTML and SVG components APIs - The react-dom package contains methods supported only in web applications",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Client APIs - The react-dom/client APIs let you render React components on the client (in the browser) Server APIs - The react-dom/server APIs let you render React components to HTML on the server",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Rules of React React has idioms  or rules  for how to express patterns in a way that is easy to understand and yields high-quality applications: Components and Hooks must be pure  Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly React calls Components and Hooks  React is responsible for rendering components and hooks when necessary to optimize the user experience",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "Rules of Hooks  Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called Legacy APIs Legacy APIs - Exported from the react package, but not recommended for use in newly written code NextHooksCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react",
          "library": "react",
          "chunk_id": "react_5"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/add-react-to-an-existing-project",
      "title": "Add React to an Existing Project \u2013 React",
      "content": "Learn ReactInstallationAdd React to an Existing ProjectIf you want to add some interactivity to your existing project, you dont have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere. NoteYou need to install Node.js for local development. Although you can try React online or with a simple HTML page, realistically most JavaScript tooling youll want to use for development requires Node.js. Using React for an entire subroute of your existing website Lets say you have an existing web app at example.com built with another server technology (like Rails), and you want to implement all routes starting with example.com/some-app/ fully with React. Heres how we recommend to set it up: Build the React part of your app using one of the React-based frameworks. Specify /some-app as the base path in your frameworks configuration (heres how: Next.js, Gatsby). Configure your server or a proxy so that all requests under /some-app/ are handled by your React app. This ensures the React part of your app can benefit from the best practices baked into those frameworks. Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you cant or dont want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next export output for Next.js, default for Gatsby) at /some-app/ instead. Using React for a part of your existing page Lets say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. Thats a common way to integrate Reactin fact, its how most React usage looked at Meta for many years! You can do this in two steps: Set up a JavaScript environment that lets you use the JSX syntax, split your code into modules with the import / export syntax, and use packages (for example, React) from the npm package registry. Render your React components where you want to see them on the page. The exact approach depends on your existing page setup, so lets walk through some details. Step 1: Set up a modular JavaScript environment A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the npm registryincluding React itself! How you do this depends on your existing setup: If your app is already split into files that use import statements, try to use the setup you already have. Check whether writing div / in your JS code causes a syntax error. If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX. If your app doesnt have an existing setup for compiling JavaScript modules, set it up with Vite. The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend. To check whether your setup works, run this command in your project folder: Terminal Copynpm install react react-dom Then add these lines of code at the top of your main JavaScript file (it might be called index.js or main.js): index.jsindex.js ResetForkimport { createRoot } from 'react-dom/client'; // Clear the existing HTML content document.body.innerHTML = 'div id=\"app\"/div'; // Render your React component instead const root = createRoot(document.getElementById('app')); root.render(h1Hello, world/h1); If the entire content of your page was replaced by a Hello, world!, everything worked! Keep reading. NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but its worth it! If you get stuck, try our community resources or the Vite Chat. Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = 'div id=\"app\"/div';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(h1Hello, world/h1); Of course, you dont actually want to clear the existing HTML content! Delete this code. Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: !-- ... somewhere in your html ... --nav id=\"navigation\"/nav!-- ... more html ... -- This lets you find that HTML element with document.getElementById and pass it to createRoot so that you can render your own React component inside: index.jsindex.htmlindex.js ResetForkimport { createRoot } from 'react-dom/client'; function NavigationBar() { // TODO: Actually implement a navigation bar return h1Hello from React!/h1; } const domNode = document.getElementById('navigation'); const root = createRoot(domNode); root.render(NavigationBar /); Notice how the original HTML content from index.html is preserved, but your own NavigationBar React component now appears inside the nav id=\"navigation\" from your HTML. Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page. When you adopt React in an existing project, its common to start with small interactive components (like buttons), and then gradually keep moving upwards until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React. Using React Native in an existing native mobile app React Native can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it.PreviousBuild a React App from ScratchNextSetupCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "example.com",
        "example.com/some-app/",
        "next export",
        "import { createRoot } from 'react-dom/client';\n\n// Clear the existing HTML content\ndocument.body.innerHTML = '<div id=\"app\"></div>';\n\n// Render your React component instead\nconst root = createRoot(document.getElementById('app'));\nroot.render(<h1>Hello, world</h1>);",
        "import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);",
        "import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id=\"app\"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);",
        "<!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... -->",
        "<!-- ... somewhere in your html ... --><nav id=\"navigation\"></nav><!-- ... more html ... -->",
        "document.getElementById",
        "import { createRoot } from 'react-dom/client';\n\nfunction NavigationBar() {\n  // TODO: Actually implement a navigation bar\n  return <h1>Hello from React!</h1>;\n}\n\nconst domNode = document.getElementById('navigation');\nconst root = createRoot(domNode);\nroot.render(<NavigationBar />);",
        "NavigationBar",
        "<nav id=\"navigation\">"
      ],
      "chunks": [
        {
          "content": "Learn ReactInstallationAdd React to an Existing ProjectIf you want to add some interactivity to your existing project, you dont have to rewrite it in React Add React to your existing stack, and render interactive React components anywhere NoteYou need to install Node js for local development Although you can try React online or with a simple HTML page, realistically most JavaScript tooling youll want to use for development requires Node js",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "Using React for an entire subroute of your existing website Lets say you have an existing web app at example com built with another server technology (like Rails), and you want to implement all routes starting with example com/some-app/ fully with React Heres how we recommend to set it up: Build the React part of your app using one of the React-based frameworks Specify /some-app as the base path in your frameworks configuration (heres how: Next js, Gatsby)",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Configure your server or a proxy so that all requests under /some-app/ are handled by your React app This ensures the React part of your app can benefit from the best practices baked into those frameworks Many React-based frameworks are full-stack and let your React app take advantage of the server However, you can use the same approach even if you cant or dont want to run JavaScript on the server In that case, serve the HTML/CSS/JS export (next export output for Next",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "js, default for Gatsby) at /some-app/ instead Using React for a part of your existing page Lets say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page Thats a common way to integrate Reactin fact, its how most React usage looked at Meta for many years",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "You can do this in two steps: Set up a JavaScript environment that lets you use the JSX syntax, split your code into modules with the import / export syntax, and use packages (for example, React) from the npm package registry Render your React components where you want to see them on the page The exact approach depends on your existing page setup, so lets walk through some details",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Step 1: Set up a modular JavaScript environment A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file It also lets you use all the wonderful packages published by other developers on the npm registryincluding React itself How you do this depends on your existing setup: If your app is already split into files that use import statements, try to use the setup you already have",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "Check whether writing div / in your JS code causes a syntax error If it causes a syntax error, you might need to transform your JavaScript code with Babel, and enable the Babel React preset to use JSX If your app doesnt have an existing setup for compiling JavaScript modules, set it up with Vite The Vite community maintains many integrations with backend frameworks, including Rails, Django, and Laravel",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "If your backend framework is not listed, follow this guide to manually integrate Vite builds with your backend To check whether your setup works, run this command in your project folder: Terminal Copynpm install react react-dom Then add these lines of code at the top of your main JavaScript file (it might be called index js or main js): index jsindex js ResetForkimport { createRoot } from 'react-dom/client'; // Clear the existing HTML content document body",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "innerHTML = 'div id=\"app\"/div'; // Render your React component instead const root = createRoot(document getElementById('app')); root render(h1Hello, world/h1); If the entire content of your page was replaced by a Hello, world , everything worked Keep reading NoteIntegrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but its worth it If you get stuck, try our community resources or the Vite Chat",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "Step 2: Render React components anywhere on the page In the previous step, you put this code at the top of your main file: import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument body innerHTML = 'div id=\"app\"/div';// Render your React component insteadconst root = createRoot(document getElementById('app'));root render(h1Hello, world/h1); Of course, you dont actually want to clear the existing HTML content Delete this code",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "Instead, you probably want to render your React components in specific places in your HTML Open your HTML page (or the server templates that generate it) and add a unique id attribute to any tag, for example: -- somewhere in your html --nav id=\"navigation\"/nav -- more html -- This lets you find that HTML element with document getElementById and pass it to createRoot so that you can render your own React component inside: index jsindex htmlindex",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "js ResetForkimport { createRoot } from 'react-dom/client'; function NavigationBar() { // TODO: Actually implement a navigation bar return h1Hello from React /h1; } const domNode = document getElementById('navigation'); const root = createRoot(domNode); root render(NavigationBar /); Notice how the original HTML content from index html is preserved, but your own NavigationBar React component now appears inside the nav id=\"navigation\" from your HTML",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "Read the createRoot usage documentation to learn more about rendering React components inside an existing HTML page When you adopt React in an existing project, its common to start with small interactive components (like buttons), and then gradually keep moving upwards until eventually your entire page is built with React If you ever reach that point, we recommend migrating to a React framework right after to get the most out of React",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Using React Native in an existing native mobile app React Native can also be integrated into existing native apps incrementally If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), follow this guide to add a React Native screen to it PreviousBuild a React App from ScratchNextSetupCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/add-react-to-an-existing-project",
          "library": "react",
          "chunk_id": "react_14"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/start-a-new-react-project",
      "title": "Creating a React App \u2013 React",
      "content": "Learn ReactInstallationCreating a React AppIf you want to build a new app or website with React, we recommend starting with a framework. If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch. Full-stack frameworks These recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of Reacts architecture. NoteFull-stack frameworks do not require a server. All the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG). These apps can be deployed to a CDN or static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case.This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your frameworks documentation for configuring the rendering strategy. Next.js (App Router) Next.jss App Router is a React framework that takes full advantage of Reacts architecture to enable full-stack React apps. Terminal Copynpx create-next-applatest Next.js is maintained by Vercel. You can deploy a Next.js app to any hosting provider that supports Node.js or Docker containers, or to your own server. Next.js also supports static export which doesnt require a server. React Router (v7) React Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms. To create a new React Router framework project, run: Terminal Copynpx create-react-routerlatest React Router is maintained by Shopify. Expo (for native apps) Expo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs. It provides an SDK for React Native that makes the native parts easier to use. To create a new Expo project, run: Terminal Copynpx create-expo-applatest If youre new to Expo, check out the Expo tutorial. Expo is maintained by Expo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services. Other frameworks There are other up-and-coming frameworks that are working towards our full stack React vision: TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite. RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications. Deep DiveWhich features make up the React teams full-stack architecture vision? Show DetailsNext.jss App Router bundler fully implements the official React Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree.For example, you can write a server-only React component as an async function that reads from a database or from a file. Then you can pass data down from it to your interactive components:// This component runs *only* on the server (or during the build).async function Talks({ confId }) { // 1. You're on the server, so you can talk to your data layer. API endpoint not required. const talks = await db.Talks.findAll({ confId }); // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger. const videos = talks.map(talk = talk.video); // 3. Pass the data down to the components that will run in the browser. return SearchableVideoList videos={videos} /;}Next.jss App Router also integrates data fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:Suspense fallback={TalksLoading /} Talks confId={conf.id} //SuspenseServer Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks. Start From Scratch If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch. Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns. Its a lot like building your own framework, instead of using a framework that already exists. The frameworks we recommend have built-in solutions for these problems. If you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a build tool like Vite, Parcel, or RSbuild. If youre a framework author interested in being included on this page, please let us know.PreviousInstallationNextBuild a React App from ScratchCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "// This component runs *only* on the server (or during the build).async function Talks({ confId }) {  // 1. You're on the server, so you can talk to your data layer. API endpoint not required.  const talks = await db.Talks.findAll({ confId });  // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.  const videos = talks.map(talk => talk.video);  // 3. Pass the data down to the components that will run in the browser.  return <SearchableVideoList videos={videos} />;}",
        "// This component runs *only* on the server (or during the build).async function Talks({ confId }) {  // 1. You're on the server, so you can talk to your data layer. API endpoint not required.  const talks = await db.Talks.findAll({ confId });  // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.  const videos = talks.map(talk => talk.video);  // 3. Pass the data down to the components that will run in the browser.  return <SearchableVideoList videos={videos} />;}",
        "<Suspense fallback={<TalksLoading />}>  <Talks confId={conf.id} /></Suspense>",
        "<Suspense fallback={<TalksLoading />}>  <Talks confId={conf.id} /></Suspense>"
      ],
      "chunks": [
        {
          "content": "Learn ReactInstallationCreating a React AppIf you want to build a new app or website with React, we recommend starting with a framework If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch Full-stack frameworks These recommended frameworks support all the features you need to deploy and scale your app in production",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "They have integrated the latest React features and take advantage of Reacts architecture NoteFull-stack frameworks do not require a server All the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG) These apps can be deployed to a CDN or static hosting service without a server Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app See your frameworks documentation for configuring the rendering strategy Next js (App Router) Next jss App Router is a React framework that takes full advantage of Reacts architecture to enable full-stack React apps Terminal Copynpx create-next-applatest Next js is maintained by Vercel You can deploy a Next",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "js app to any hosting provider that supports Node js or Docker containers, or to your own server Next js also supports static export which doesnt require a server React Router (v7) React Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "To create a new React Router framework project, run: Terminal Copynpx create-react-routerlatest React Router is maintained by Shopify Expo (for native apps) Expo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs It provides an SDK for React Native that makes the native parts easier to use To create a new Expo project, run: Terminal Copynpx create-expo-applatest If youre new to Expo, check out the Expo tutorial",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Expo is maintained by Expo (the company) Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions Expo additionally provides opt-in paid cloud services Other frameworks There are other up-and-coming frameworks that are working towards our full stack React vision: TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications Deep DiveWhich features make up the React teams full-stack architecture vision Show DetailsNext jss App Router bundler fully implements the official React Server Components specification",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "This lets you mix build-time, server-only, and interactive components in a single React tree For example, you can write a server-only React component as an async function that reads from a database or from a file Then you can pass data down from it to your interactive components:// This component runs *only* on the server (or during the build) async function Talks({ confId }) { // 1 You're on the server, so you can talk to your data layer API endpoint not required const talks = await db Talks",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "findAll({ confId }); // 2 Add any amount of rendering logic It won't make your JavaScript bundle larger const videos = talks map(talk = talk video); // 3 Pass the data down to the components that will run in the browser return SearchableVideoList videos={videos} /;}Next jss App Router also integrates data fetching with Suspense",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:Suspense fallback={TalksLoading /} Talks confId={conf id} //SuspenseServer Components and Suspense are React features rather than Next js features However, adopting them at the framework level requires buy-in and non-trivial implementation work At the moment, the Next js App Router is the most complete implementation",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks Start From Scratch If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns Its a lot like building your own framework, instead of using a framework that already exists The frameworks we recommend have built-in solutions for these problems",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "If you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a build tool like Vite, Parcel, or RSbuild If youre a framework author interested in being included on this page, please let us know PreviousInstallationNextBuild a React App from ScratchCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/start-a-new-react-project",
          "library": "react",
          "chunk_id": "react_13"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/installation",
      "title": "Installation \u2013 React",
      "content": "Learn ReactInstallationReact has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started. Try React You dont need to install anything to play with React. Try editing this sandbox! App.jsApp.js ResetForkfunction Greeting({ name }) { return h1Hello, {name}/h1; } export default function App() { return Greeting name=\"world\" / } You can edit it directly or open it in a new tab by pressing the Fork button in the upper right corner. Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example, CodeSandbox, StackBlitz, or CodePen. To try React locally on your computer, download this HTML page. Open it in your editor and in your browser! Creating a React App If you want to start a new React app, you can create a React app using a recommended framework. Build a React App from Scratch If a framework is not a good fit for your project, you prefer to build your own framework, or you just want to learn the basics of a React app you can build a React app from scratch. Add React to an existing project If want to try using React in your existing app or a website, you can add React to an existing project. NoteShould I use Create React App? No. Create React App has been deprecated. For more information, see Sunsetting Create React App. Next steps Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day.PreviousThinking in ReactNextCreating a React AppCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "function Greeting({ name }) {\n  return <h1>Hello, {name}</h1>;\n}\n\nexport default function App() {\n  return <Greeting name=\"world\" />\n}"
      ],
      "chunks": [
        {
          "content": "Learn ReactInstallationReact has been designed from the start for gradual adoption You can use as little or as much React as you need Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started Try React You dont need to install anything to play with React Try editing this sandbox App jsApp",
          "url": "https://react.dev/learn/installation",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "js ResetForkfunction Greeting({ name }) { return h1Hello, {name}/h1; } export default function App() { return Greeting name=\"world\" / } You can edit it directly or open it in a new tab by pressing the Fork button in the upper right corner Most pages in the React documentation contain sandboxes like this Outside of the React documentation, there are many online sandboxes that support React: for example, CodeSandbox, StackBlitz, or CodePen",
          "url": "https://react.dev/learn/installation",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "To try React locally on your computer, download this HTML page Open it in your editor and in your browser Creating a React App If you want to start a new React app, you can create a React app using a recommended framework Build a React App from Scratch If a framework is not a good fit for your project, you prefer to build your own framework, or you just want to learn the basics of a React app you can build a React app from scratch",
          "url": "https://react.dev/learn/installation",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Add React to an existing project If want to try using React in your existing app or a website, you can add React to an existing project NoteShould I use Create React App No Create React App has been deprecated For more information, see Sunsetting Create React App Next steps Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day PreviousThinking in ReactNextCreating a React AppCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/installation",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/installation",
          "library": "react",
          "chunk_id": "react_4"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/tutorial-tic-tac-toe",
      "title": "Tutorial: Tic-Tac-Toe \u2013 React",
      "content": "Learn ReactQuick StartTutorial: Tic-Tac-ToeYou will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques youll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React. NoteThis tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, start with Describing the UI. The tutorial is divided into several sections: Setup for the tutorial will give you a starting point to follow the tutorial. Overview will teach you the fundamentals of React: components, props, and state. Completing the game will teach you the most common techniques in React development. Adding time travel will give you a deeper insight into the unique strengths of React. What are you building? In this tutorial, youll build an interactive tic-tac-toe game with React. You can see what it will look like when youre finished here: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more If the code doesnt make sense to you yet, or if you are unfamiliar with the codes syntax, dont worry! The goal of this tutorial is to help you understand React and its syntax. We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that youll notice is that there is a numbered list to the right of the games board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses. Once youve played around with the finished tic-tac-toe game, keep scrolling. Youll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game. Setup for the tutorial In the live code editor below, click Fork in the top-right corner to open the editor in a new tab using the website CodeSandbox. CodeSandbox lets you write code in your browser and preview how your users will see the app youve created. The new tab should display an empty square and the starter code for this tutorial. App.jsApp.js ResetForkexport default function Square() { return button className=\"square\"X/button; } NoteYou can also follow this tutorial using your local development environment. To do this, you need to: Install Node.js In the CodeSandbox tab you opened earlier, press the top-left corner button to open the menu, and then choose Download Sandbox in that menu to download an archive of the files locally Unzip the archive, then open a terminal and cd to the directory you unzipped Install the dependencies with npm install Run npm start to start a local server and follow the prompts to view the code running in a browser If you get stuck, dont let this stop you! Follow along online instead and try a local setup again later. Overview Now that youre set up, lets get an overview of React! Inspecting the starter code In CodeSandbox youll see three main sections: The Files section with a list of files like App.js, index.js, styles.css and a folder called public The code editor where youll see the source code of your selected file The browser section where youll see how the code youve written will be displayed The App.js file should be selected in the Files section. The contents of that file in the code editor should be: export default function Square() { return button className=\"square\"X/button;} The browser section should be displaying a square with an X in it like this: Now lets have a look at the files in the starter code. App.js The code in App.js creates a component. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Lets look at the component line by line to see whats going on: export default function Square() { return button className=\"square\"X/button;} The first line defines a function called Square. The export JavaScript keyword makes this function accessible outside of this file. The default keyword tells other files using your code that its the main function in your file. export default function Square() { return button className=\"square\"X/button;} The second line returns a button. The return JavaScript keyword means whatever comes after is returned as a value to the caller of the function. button is a JSX element. A JSX element is a combination of JavaScript code and HTML tags that describes what youd like to display. className=\"square\" is a button property or prop that tells CSS how to style the button. X is the text displayed inside of the button and /button closes the JSX element to indicate that any following content shouldnt be placed inside the button. styles.css Click on the file labeled styles.css in the Files section of CodeSandbox. This file defines the styles for your React app. The first two CSS selectors (* and body) define the style of large parts of your app while the .square selector defines the style of any component where the className property is set to square. In your code, that would match the button from your Square component in the App.js file. index.js Click on the file labeled index.js in the Files section of CodeSandbox. You wont be editing this file during the tutorial but it is the bridge between the component you created in the App.js file and the web browser. import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';import './styles.css';import App from './App'; Lines 1-5 bring all the necessary pieces together: React Reacts library to talk to web browsers (React DOM) the styles for your components the component you created in App.js. The remainder of the file brings all the pieces together and injects the final product into index.html in the public folder. Building the board Lets get back to App.js. This is where youll spend the rest of the tutorial. Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this: export default function Square() { return button className=\"square\"X/buttonbutton className=\"square\"X/button;} Youll get this error: Console/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX Fragment .../? React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can use Fragments ( and /) to wrap multiple adjacent JSX elements like this: export default function Square() { return (  button className=\"square\"X/button button className=\"square\"X/button / );} Now you should see: Great! Now you just need to copy-paste a few times to add nine squares and Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this youll need to group your squares into rows with divs and add some CSS classes. While youre at it, youll give each square a number to make sure you know where each square is displayed. In the App.js file, update the Square component to look like this: export default function Square() { return (  div className=\"board-row\" button className=\"square\"1/button button className=\"square\"2/button button className=\"square\"3/button /div div className=\"board-row\" button className=\"square\"4/button button className=\"square\"5/button button className=\"square\"6/button /div div className=\"board-row\" button className=\"square\"7/button button className=\"square\"8/button button className=\"square\"9/button /div / );} The CSS defined in styles.css styles the divs with the className of board-row. Now that youve grouped your components into rows with the styled divs you have your tic-tac-toe board: But you now have a problem. Your component named Square, really isnt a square anymore. Lets fix that by changing the name to Board: export default function Board() { //...} At this point your code should look something like this: App.jsApp.js ResetForkexport default function Board() { return (  div className=\"board-row\" button className=\"square\"1/button button className=\"square\"2/button button className=\"square\"3/button /div div className=\"board-row\" button className=\"square\"4/button button className=\"square\"5/button button className=\"square\"6/button /div div className=\"board-row\" button className=\"square\"7/button button className=\"square\"8/button button className=\"square\"9/button /div / ); } Show more NotePsssst Thats a lot to type! Its okay to copy and paste code from this page. However, if youre up for a little challenge, we recommend only copying code that youve manually typed at least once yourself. Passing data through props Next, youll want to change the value of a square from empty to X when the user clicks on the square. With how youve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, Reacts component architecture allows you to create a reusable component to avoid messy, duplicated code. First, you are going to copy the line defining your first square (button className=\"square\"1/button) from your Board component into a new Square component: function Square() { return button className=\"square\"1/button;}export default function Board() { // ...} Then youll update the Board component to render that Square component using JSX syntax: // ...export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / );} Note how unlike the browser divs, your own components Board and Square must start with a capital letter. Lets take a look: Oh no! You lost the numbered squares you had before. Now each square says 1. To fix this, you will use props to pass the value each square should have from the parent component (Board) to its child (Square). Update the Square component to read the value prop that youll pass from the Board: function Square({ value }) { return button className=\"square\"1/button;} function Square({ value }) indicates the Square component can be passed a prop called value. Now you want to display that value instead of 1 inside every square. Try doing it like this: function Square({ value }) { return button className=\"square\"value/button;} Oops, this is not what you wanted: You wanted to render the JavaScript variable called value from your component, not the word value. To escape into JavaScript from JSX, you need curly braces. Add curly braces around value in JSX like so: function Square({ value }) { return button className=\"square\"{value}/button;} For now, you should see an empty board: This is because the Board component hasnt passed the value prop to each Square component it renders yet. To fix it youll add the value prop to each Square component rendered by the Board component: export default function Board() { return (  div className=\"board-row\" Square value=\"1\" / Square value=\"2\" / Square value=\"3\" / /div div className=\"board-row\" Square value=\"4\" / Square value=\"5\" / Square value=\"6\" / /div div className=\"board-row\" Square value=\"7\" / Square value=\"8\" / Square value=\"9\" / /div / );} Now you should see a grid of numbers again: Your updated code should look like this: App.jsApp.js ResetForkfunction Square({ value }) { return button className=\"square\"{value}/button; } export default function Board() { return (  div className=\"board-row\" Square value=\"1\" / Square value=\"2\" / Square value=\"3\" / /div div className=\"board-row\" Square value=\"4\" / Square value=\"5\" / Square value=\"6\" / /div div className=\"board-row\" Square value=\"7\" / Square value=\"8\" / Square value=\"9\" / /div / ); } Show more Making an interactive component Lets fill the Square component with an X when you click it. Declare a function called handleClick inside of the Square. Then, add onClick to the props of the button JSX element returned from the Square: function Square({ value }) { function handleClick() { console.log('clicked!'); } return ( button className=\"square\" onClick={handleClick}  {value} /button );} If you click on a square now, you should see a log saying \"clicked!\" in the Console tab at the bottom of the Browser section in CodeSandbox. Clicking the square more than once will log \"clicked!\" again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first \"clicked!\" log. NoteIf you are following this tutorial using your local development environment, you need to open your browsers Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcut Shift + Ctrl + J (on Windows/Linux) or Option +  + J (on macOS). As a next step, you want the Square component to remember that it got clicked, and fill it with an X mark. To remember things, components use state. React provides a special function called useState that you can call from your component to let it remember things. Lets store the current value of the Square in state, and change it when the Square is clicked. Import useState at the top of the file. Remove the value prop from the Square component. Instead, add a new line at the start of the Square that calls useState. Have it return a state variable called value: import { useState } from 'react';function Square() { const [value, setValue] = useState(null); function handleClick() { //... value stores the value and setValue is a function that can be used to change the value. The null passed to useState is used as the initial value for this state variable, so value here starts off equal to null. Since the Square component no longer accepts props anymore, youll remove the value prop from all nine of the Square components created by the Board component: // ...export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / );} Now youll change Square to display an X when clicked. Replace the console.log(\"clicked!\"); event handler with setValue('X');. Now your Square component looks like this: function Square() { const [value, setValue] = useState(null); function handleClick() { setValue('X'); } return ( button className=\"square\" onClick={handleClick}  {value} /button );} By calling this set function from an onClick handler, youre telling React to re-render that Square whenever its button is clicked. After the update, the Squares value will be 'X', so youll see the X on the game board. Click on any Square, and X should show up: Each Square has its own state: the value stored in each Square is completely independent of the others. When you call a set function in a component, React automatically updates the child components inside too. After youve made the above changes, your code will look like this: App.jsApp.js ResetForkimport { useState } from 'react'; function Square() { const [value, setValue] = useState(null); function handleClick() { setValue('X'); } return ( button className=\"square\" onClick={handleClick}  {value} /button ); } export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / ); } Show more React Developer Tools React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of the browser section in CodeSandbox: To inspect a particular component on the screen, use the button in the top left corner of React DevTools: NoteFor local development, React DevTools is available as a Chrome, Firefox, and Edge browser extension. Install it, and the Components tab will appear in your browser Developer Tools for sites using React. Completing the game By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing Xs and Os on the board, and you need a way to determine a winner. Lifting state up Currently, each Square component maintains a part of the games state. To check for a winner in a tic-tac-toe game, the Board would need to somehow know the state of each of the 9 Square components. How would you approach that? At first, you might guess that the Board needs to ask each Square for that Squares state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the games state in the parent Board component instead of in each Square. The Board component can tell each Square what to display by passing a prop, like you did when you passed a number to each Square. To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent. Lifting state into a parent component is common when React components are refactored. Lets take this opportunity to try it out. Edit the Board component so that it declares a state variable named squares that defaults to an array of 9 nulls corresponding to the 9 squares: // ...export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); return ( // ... );} Array(9).fill(null) creates an array with nine elements and sets each of them to null. The useState() call around it declares a squares state variable thats initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, the squares array will look like this: ['O', null, 'X', 'X', 'X', 'O', 'O', null, null] Now your Board component needs to pass the value prop down to each Square that it renders: export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); return (  div className=\"board-row\" Square value={squares[0]} / Square value={squares[1]} / Square value={squares[2]} / /div div className=\"board-row\" Square value={squares[3]} / Square value={squares[4]} / Square value={squares[5]} / /div div className=\"board-row\" Square value={squares[6]} / Square value={squares[7]} / Square value={squares[8]} / /div / );} Next, youll edit the Square component to receive the value prop from the Board component. This will require removing the Square components own stateful tracking of value and the buttons onClick prop: function Square({value}) { return button className=\"square\"{value}/button;} At this point you should see an empty tic-tac-toe board: And your code should look like this: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value }) { return button className=\"square\"{value}/button; } export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); return (  div className=\"board-row\" Square value={squares[0]} / Square value={squares[1]} / Square value={squares[2]} / /div div className=\"board-row\" Square value={squares[3]} / Square value={squares[4]} / Square value={squares[5]} / /div div className=\"board-row\" Square value={squares[6]} / Square value={squares[7]} / Square value={squares[8]} / /div / ); } Show more Each Square will now receive a value prop that will either be 'X', 'O', or null for empty squares. Next, you need to change what happens when a Square is clicked. The Board component now maintains which squares are filled. Youll need to create a way for the Square to update the Boards state. Since state is private to a component that defines it, you cannot update the Boards state directly from Square. Instead, youll pass down a function from the Board component to the Square component, and youll have Square call that function when a square is clicked. Youll start with the function that the Square component will call when it is clicked. Youll call that function onSquareClick: function Square({ value }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button );} Next, youll add the onSquareClick function to the Square components props: function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button );} Now youll connect the onSquareClick prop to a function in the Board component that youll name handleClick. To connect onSquareClick to handleClick youll pass a function to the onSquareClick prop of the first Square component: export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={handleClick} / //... );} Lastly, you will define the handleClick function inside the Board component to update the squares array holding your boards state: export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick() { const nextSquares = squares.slice(); nextSquares[0] = \"X\"; setSquares(nextSquares); } return ( // ... )} The handleClick function creates a copy of the squares array (nextSquares) with the JavaScript slice() Array method. Then, handleClick updates the nextSquares array to add X to the first ([0] index) square. Calling the setSquares function lets React know the state of the component has changed. This will trigger a re-render of the components that use the squares state (Board) as well as its child components (the Square components that make up the board). NoteJavaScript supports closures which means an inner function (e.g. handleClick) has access to variables and functions defined in an outer function (e.g. Board). The handleClick function can read the squares state and call the setSquares method because they are both defined inside of the Board function. Now you can add Xs to the board but only to the upper left square. Your handleClick function is hardcoded to update the index for the upper left square (0). Lets update handleClick to be able to update any square. Add an argument i to the handleClick function that takes the index of the square to update: export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick(i) { const nextSquares = squares.slice(); nextSquares[i] = \"X\"; setSquares(nextSquares); } return ( // ... )} Next, you will need to pass that i to handleClick. You could try to set the onSquareClick prop of square to be handleClick(0) directly in the JSX like this, but it wont work: Square value={squares[0]} onSquareClick={handleClick(0)} / Here is why this doesnt work. The handleClick(0) call will be a part of rendering the board component. Because handleClick(0) alters the state of the board component by calling setSquares, your entire board component will be re-rendered again. But this runs handleClick(0) again, leading to an infinite loop: ConsoleToo many re-renders. React limits the number of renders to prevent an infinite loop. Why didnt this problem happen earlier? When you were passing onSquareClick={handleClick}, you were passing the handleClick function down as a prop. You were not calling it! But now you are calling that function right awaynotice the parentheses in handleClick(0)and thats why it runs too early. You dont want to call handleClick until the user clicks! You could fix this by creating a function like handleFirstSquareClick that calls handleClick(0), a function like handleSecondSquareClick that calls handleClick(1), and so on. You would pass (rather than call) these functions down as props like onSquareClick={handleFirstSquareClick}. This would solve the infinite loop. However, defining nine different functions and giving each of them a name is too verbose. Instead, lets do this: export default function Board() { // ... return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / // ... );} Notice the new () = syntax. Here, () = handleClick(0) is an arrow function, which is a shorter way to define functions. When the square is clicked, the code after the = arrow will run, calling handleClick(0). Now you need to update the other eight squares to call handleClick from the arrow functions you pass. Make sure that the argument for each call of the handleClick corresponds to the index of the correct square: export default function Board() { // ... return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / );}; Now you can again add Xs to any square on the board by clicking on them: But this time all the state management is handled by the Board component! This is what your code should look like: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick(i) { const nextSquares = squares.slice(); nextSquares[i] = 'X'; setSquares(nextSquares); } return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } Show more Now that your state handling is in the Board component, the parent Board component passes props to the child Square components so that they can be displayed correctly. When clicking on a Square, the child Square component now asks the parent Board component to update the state of the board. When the Boards state changes, both the Board component and every child Square re-renders automatically. Keeping the state of all squares in the Board component will allow it to determine the winner in the future. Lets recap what happens when a user clicks the top left square on your board to add an X to it: Clicking on the upper left square runs the function that the button received as its onClick prop from the Square. The Square component received that function as its onSquareClick prop from the Board. The Board component defined that function directly in the JSX. It calls handleClick with an argument of 0. handleClick uses the argument (0) to update the first element of the squares array from null to X. The squares state of the Board component was updated, so the Board and all of its children re-render. This causes the value prop of the Square component with index 0 to change from null to X. In the end the user sees that the upper left square has changed from empty to having an X after clicking it. NoteThe DOM button elements onClick attribute has a special meaning to React because it is a built-in component. For custom components like Square, the naming is up to you. You could give any name to the Squares onSquareClick prop or Boards handleClick function, and the code would work the same. In React, its conventional to use onSomething names for props which represent events and handleSomething for the function definitions which handle those events. Why immutability is important Note how in handleClick, you call .slice() to create a copy of the squares array instead of modifying the existing array. To explain why, we need to discuss immutability and why immutability is important to learn. There are generally two approaches to changing data. The first approach is to mutate the data by directly changing the datas values. The second approach is to replace the data with a new copy which has the desired changes. Here is what it would look like if you mutated the squares array: const squares = [null, null, null, null, null, null, null, null, null];squares[0] = 'X';// Now `squares` is [\"X\", null, null, null, null, null, null, null, null]; And here is what it would look like if you changed data without mutating the squares array: const squares = [null, null, null, null, null, null, null, null, null];const nextSquares = ['X', null, null, null, null, null, null, null, null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null` The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits. Immutability makes complex features much easier to implement. Later in this tutorial, you will implement a time travel feature that lets you review the games history and jump back to past moves. This functionality isnt specific to gamesan ability to undo and redo certain actions is a common requirement for apps. Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later. There is also another benefit of immutability. By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that werent affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldnt actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasnt affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. You can learn more about how React chooses when to re-render a component in the memo API reference. Taking turns Its now time to fix a major defect in this tic-tac-toe game: the Os cannot be marked on the board. Youll set the first move to be X by default. Lets keep track of this by adding another piece of state to the Board component: function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9).fill(null)); // ...} Each time a player moves, xIsNext (a boolean) will be flipped to determine which player goes next and the games state will be saved. Youll update the Boards handleClick function to flip the value of xIsNext: export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick(i) { const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = \"X\"; } else { nextSquares[i] = \"O\"; } setSquares(nextSquares); setXIsNext(!xIsNext); } return ( //... );} Now, as you click on different squares, they will alternate between X and O, as they should! But wait, theres a problem. Try clicking on the same square multiple times: The X is overwritten by an O! While this would add a very interesting twist to the game, were going to stick to the original rules for now. When you mark a square with an X or an O you arent first checking to see if the square already has an X or O value. You can fix this by returning early. Youll check to see if the square already has an X or an O. If the square is already filled, you will return in the handleClick function earlybefore it tries to update the board state. function handleClick(i) { if (squares[i]) { return; } const nextSquares = squares.slice(); //...} Now you can only add Xs or Os to empty squares! Here is what your code should look like at this point: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick(i) { if (squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } setSquares(nextSquares); setXIsNext(!xIsNext); } return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } Show more Declaring a winner Now that the players can take turns, youll want to show when the game is won and there are no more turns to make. To do this youll add a helper function called calculateWinner that takes an array of 9 squares, checks for a winner and returns 'X', 'O', or null as appropriate. Dont worry too much about the calculateWinner function; its not specific to React: export default function Board() { //...}function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null;} NoteIt does not matter whether you define calculateWinner before or after the Board. Lets put it at the end so that you dont have to scroll past it every time you edit your components. You will call calculateWinner(squares) in the Board components handleClick function to check if a player has won. You can perform this check at the same time you check if a user has clicked a square that already has an X or an O. Wed like to return early in both cases: function handleClick(i) { if (squares[i]  calculateWinner(squares)) { return; } const nextSquares = squares.slice(); //...} To let the players know when the game is over, you can display text such as Winner: X or Winner: O. To do that youll add a status section to the Board component. The status will display the winner if the game is over and if the game is ongoing youll display which players turn is next: export default function Board() { // ... const winner = calculateWinner(squares); let status; if (winner) { status = \"Winner: \" + winner; } else { status = \"Next player: \" + (xIsNext ? \"X\" : \"O\"); } return (  div className=\"status\"{status}/div div className=\"board-row\" // ... )} Congratulations! You now have a working tic-tac-toe game. And youve just learned the basics of React too. So you are the real winner here. Here is what the code should look like: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9).fill(null)); function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } setSquares(nextSquares); setXIsNext(!xIsNext); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Adding time travel As a final exercise, lets make it possible to go back in time to the previous moves in the game. Storing a history of moves If you mutated the squares array, implementing time travel would be very difficult. However, you used slice() to create a new copy of the squares array after every move, and treated it as immutable. This will allow you to store every past version of the squares array, and navigate between the turns that have already happened. Youll store the past squares arrays in another array called history, which youll store as a new state variable. The history array represents all board states, from the first to the last move, and has a shape like this: [ // Before first move [null, null, null, null, null, null, null, null, null], // After first move [null, null, null, null, 'X', null, null, null, null], // After second move [null, null, null, null, 'X', null, null, null, 'O'], // ...] Lifting state up, again You will now write a new top-level component called Game to display a list of past moves. Thats where you will place the history state that contains the entire game history. Placing the history state into the Game component will let you remove the squares state from its child Board component. Just like you lifted state up from the Square component into the Board component, you will now lift it up from the Board into the top-level Game component. This gives the Game component full control over the Boards data and lets it instruct the Board to render previous turns from the history. First, add a Game component with export default. Have it render the Board component and some markup: function Board() { // ...}export default function Game() { return ( div className=\"game\" div className=\"game-board\" Board / /div div className=\"game-info\" ol{/*TODO*/}/ol /div /div );} Note that you are removing the export default keywords before the function Board() { declaration and adding them before the function Game() { declaration. This tells your index.js file to use the Game component as the top-level component instead of your Board component. The additional divs returned by the Game component are making room for the game information youll add to the board later. Add some state to the Game component to track which player is next and the history of moves: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); // ... Notice how [Array(9).fill(null)] is an array with a single item, which itself is an array of 9 nulls. To render the squares for the current move, youll want to read the last squares array from the history. You dont need useState for thisyou already have enough information to calculate it during rendering: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; // ... Next, create a handlePlay function inside the Game component that will be called by the Board component to update the game. Pass xIsNext, currentSquares and handlePlay as props to the Board component: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; function handlePlay(nextSquares) { // TODO } return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / //... )} Lets make the Board component fully controlled by the props it receives. Change the Board component to take three props: xIsNext, squares, and a new onPlay function that Board can call with the updated squares array when a player makes a move. Next, remove the first two lines of the Board function that call useState: function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { //... } // ...} Now replace the setSquares and setXIsNext calls in handleClick in the Board component with a single call to your new onPlay function so the Game component can update the Board when the user clicks a square: function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = \"X\"; } else { nextSquares[i] = \"O\"; } onPlay(nextSquares); } //...} The Board component is fully controlled by the props passed to it by the Game component. You need to implement the handlePlay function in the Game component to get the game working again. What should handlePlay do when called? Remember that Board used to call setSquares with an updated array; now it passes the updated squares array to onPlay. The handlePlay function needs to update Games state to trigger a re-render, but you dont have a setSquares function that you can call any moreyoure now using the history state variable to store this information. Youll want to update history by appending the updated squares array as a new history entry. You also want to toggle xIsNext, just as Board used to do: export default function Game() { //... function handlePlay(nextSquares) { setHistory([...history, nextSquares]); setXIsNext(!xIsNext); } //...} Here, [...history, nextSquares] creates a new array that contains all the items in history, followed by nextSquares. (You can read the ...history spread syntax as enumerate all the items in history.) For example, if history is [[null,null,null], [\"X\",null,null]] and nextSquares is [\"X\",null,\"O\"], then the new [...history, nextSquares] array will be [[null,null,null], [\"X\",null,null], [\"X\",null,\"O\"]]. At this point, youve moved the state to live in the Game component, and the UI should be fully working, just as it was before the refactor. Here is what the code should look like at this point: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; function handlePlay(nextSquares) { setHistory([...history, nextSquares]); setXIsNext(!xIsNext); } return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{/*TODO*/}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Showing the past moves Since you are recording the tic-tac-toe games history, you can now display a list of past moves to the player. React elements like button are regular JavaScript objects; you can pass them around in your application. To render multiple items in React, you can use an array of React elements. You already have an array of history moves in state, so now you need to transform it to an array of React elements. In JavaScript, to transform one array into another, you can use the array map method: [1, 2, 3].map((x) = x * 2) // [2, 4, 6] Youll use map to transform your history of moves into React elements representing buttons on the screen, and display a list of buttons to jump to past moves. Lets map over the history in the Game component: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; function handlePlay(nextSquares) { setHistory([...history, nextSquares]); setXIsNext(!xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div );} You can see what your code should look like below. Note that you should see an error in the developer tools console that says: ConsoleWarning: Each child in an array or iterator should have a unique key prop. Check the render method of `Game`. Youll fix this error in the next section. App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; function handlePlay(nextSquares) { setHistory([...history, nextSquares]); setXIsNext(!xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more As you iterate through the history array inside the function you passed to map, the squares argument goes through each element of history, and the move argument goes through each array index: 0, 1, 2, . (In most cases, youd need the actual array elements, but to render a list of moves you will only need indexes.) For each move in the tic-tac-toe games history, you create a list item li which contains a button button. The button has an onClick handler which calls a function called jumpTo (that you havent implemented yet). For now, you should see a list of the moves that occurred in the game and an error in the developer tools console. Lets discuss what the key error means. Picking a key When you render a list, React stores some information about each rendered list item. When you update a list, React needs to determine what has changed. You could have added, removed, re-arranged, or updated the lists items. Imagine transitioning from liAlexa: 7 tasks left/liliBen: 5 tasks left/li to liBen: 9 tasks left/liliClaudia: 8 tasks left/liliAlexa: 5 tasks left/li In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Bens ordering and inserted Claudia between Alexa and Ben. However, React is a computer program and does not know what you intended, so you need to specify a key property for each list item to differentiate each list item from its siblings. If your data was from a database, Alexa, Ben, and Claudias database IDs could be used as keys. li key={user.id} {user.name}: {user.taskCount} tasks left/li When a list is re-rendered, React takes each list items key and searches the previous lists items for a matching key. If the current list has a key that didnt exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved. Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a components key changes, the component will be destroyed and re-created with a new state. key is a special and reserved property in React. When an element is created, React extracts the key property and stores the key directly on the returned element. Even though key may look like it is passed as props, React automatically uses key to decide which components to update. Theres no way for a component to ask what key its parent specified. Its strongly recommended that you assign proper keys whenever you build dynamic lists. If you dont have an appropriate key, you may want to consider restructuring your data so that you do. If no key is specified, React will report an error and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a lists items or inserting/removing list items. Explicitly passing key={i} silences the error but has the same problems as array indices and is not recommended in most cases. Keys do not need to be globally unique; they only need to be unique between components and their siblings. Implementing time travel In the tic-tac-toe games history, each past move has a unique ID associated with it: its the sequential number of the move. Moves will never be re-ordered, deleted, or inserted in the middle, so its safe to use the move index as a key. In the Game function, you can add the key as li key={move}, and if you reload the rendered game, Reacts key error should disappear: const moves = history.map((squares, move) = { //... return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li );}); App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const currentSquares = history[history.length - 1]; function handlePlay(nextSquares) { setHistory([...history, nextSquares]); setXIsNext(!xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Before you can implement jumpTo, you need the Game component to keep track of which step the user is currently viewing. To do this, define a new state variable called currentMove, defaulting to 0: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[history.length - 1]; //...} Next, update the jumpTo function inside Game to update that currentMove. Youll also set xIsNext to true if the number that youre changing currentMove to is even. export default function Game() { // ... function jumpTo(nextMove) { setCurrentMove(nextMove); setXIsNext(nextMove  2 === 0); } //...} You will now make two changes to the Games handlePlay function which is called when you click on a square. If you go back in time and then make a new move from that point, you only want to keep the history up to that point. Instead of adding nextSquares after all items (... spread syntax) in history, youll add it after all items in history.slice(0, currentMove + 1) so that youre only keeping that portion of the old history. Each time a move is made, you need to update currentMove to point to the latest history entry. function handlePlay(nextSquares) { const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); setXIsNext(!xIsNext);} Finally, you will modify the Game component to render the currently selected move, instead of always rendering the final move: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[currentMove]; // ...} If you click on any step in the games history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred. App.jsApp.js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); setXIsNext(!xIsNext); } function jumpTo(nextMove) { setCurrentMove(nextMove); setXIsNext(nextMove  2 === 0); } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Final cleanup If you look at the code very closely, you may notice that xIsNext === true when currentMove is even and xIsNext === false when currentMove is odd. In other words, if you know the value of currentMove, then you can always figure out what xIsNext should be. Theres no reason for you to store both of these in state. In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand. Change Game so that it doesnt store xIsNext as a separate state variable and instead figures it out based on the currentMove: export default function Game() { const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } // ...} You no longer need the xIsNext state declaration or the calls to setXIsNext. Now, theres no chance for xIsNext to get out of sync with currentMove, even if you make a mistake while coding the components. Wrapping up Congratulations! Youve created a tic-tac-toe game that: Lets you play tic-tac-toe, Indicates when a player has won the game, Stores a games history as a game progresses, Allows players to review a games history and see previous versions of a games board. Nice work! We hope you now feel like you have a decent grasp of how React works. Check out the final result here: App.jsApp.js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext ? 'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [history, setHistory] = useState([Array(9).fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } const moves = history.map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty: For the current move only, show You are at move  instead of a button. Rewrite Board to use two loops to make the squares instead of hardcoding them. Add a toggle button that lets you sort the moves in either ascending or descending order. When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw). Display the location for each move in the format (row, col) in the move history list. Throughout this tutorial, youve touched on React concepts including elements, components, props, and state. Now that youve seen how these concepts work when building a game, check out Thinking in React to see how the same React concepts work when building an apps UI.PreviousQuick StartNextThinking in ReactCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const [currentMove, setCurrentMove] = useState(0);\n  const xIsNext = currentMove % 2 === 0;\n  const currentSquares = history[currentMove];\n\n  function handlePlay(nextSquares) {\n    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\n    setHistory(nextHistory);\n    setCurrentMove(nextHistory.length - 1);\n  }\n\n  function jumpTo(nextMove) {\n    setCurrentMove(nextMove);\n  }\n\n  const moves = history.map((squares, move) => {\n    let description;\n    if (move > 0) {\n      description = 'Go to move #' + move;\n    } else {\n      description = 'Go to game start';\n    }\n    return (\n      <li key={move}>\n        <button onClick={() => jumpTo(move)}>{description}</button>\n      </li>\n    );\n  });\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{moves}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "export default function Square() {\n  return <button className=\"square\">X</button>;\n}",
        "npm install",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button>;}",
        "className=\"square\"",
        "import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';import './styles.css';import App from './App';",
        "import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';import './styles.css';import App from './App';",
        "export default function Square() {  return <button className=\"square\">X</button><button className=\"square\">X</button>;}",
        "export default function Square() {  return <button className=\"square\">X</button><button className=\"square\">X</button>;}",
        "export default function Square() {  return (    <>      <button className=\"square\">X</button>      <button className=\"square\">X</button>    </>  );}",
        "export default function Square() {  return (    <>      <button className=\"square\">X</button>      <button className=\"square\">X</button>    </>  );}",
        "export default function Square() {  return (    <>      <div className=\"board-row\">        <button className=\"square\">1</button>        <button className=\"square\">2</button>        <button className=\"square\">3</button>      </div>      <div className=\"board-row\">        <button className=\"square\">4</button>        <button className=\"square\">5</button>        <button className=\"square\">6</button>      </div>      <div className=\"board-row\">        <button className=\"square\">7</button>        <button className=\"square\">8</button>        <button className=\"square\">9</button>      </div>    </>  );}",
        "export default function Square() {  return (    <>      <div className=\"board-row\">        <button className=\"square\">1</button>        <button className=\"square\">2</button>        <button className=\"square\">3</button>      </div>      <div className=\"board-row\">        <button className=\"square\">4</button>        <button className=\"square\">5</button>        <button className=\"square\">6</button>      </div>      <div className=\"board-row\">        <button className=\"square\">7</button>        <button className=\"square\">8</button>        <button className=\"square\">9</button>      </div>    </>  );}",
        "export default function Board() {  //...}",
        "export default function Board() {  //...}",
        "export default function Board() {\n  return (\n    <>\n      <div className=\"board-row\">\n        <button className=\"square\">1</button>\n        <button className=\"square\">2</button>\n        <button className=\"square\">3</button>\n      </div>\n      <div className=\"board-row\">\n        <button className=\"square\">4</button>\n        <button className=\"square\">5</button>\n        <button className=\"square\">6</button>\n      </div>\n      <div className=\"board-row\">\n        <button className=\"square\">7</button>\n        <button className=\"square\">8</button>\n        <button className=\"square\">9</button>\n      </div>\n    </>\n  );\n}",
        "<button className=\"square\">1</button>",
        "function Square() {  return <button className=\"square\">1</button>;}export default function Board() {  // ...}",
        "function Square() {  return <button className=\"square\">1</button>;}export default function Board() {  // ...}",
        "// ...export default function Board() {  return (    <>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>    </>  );}",
        "// ...export default function Board() {  return (    <>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>    </>  );}",
        "function Square({ value }) {  return <button className=\"square\">1</button>;}",
        "function Square({ value }) {  return <button className=\"square\">1</button>;}",
        "function Square({ value })",
        "function Square({ value }) {  return <button className=\"square\">value</button>;}",
        "function Square({ value }) {  return <button className=\"square\">value</button>;}",
        "function Square({ value }) {  return <button className=\"square\">{value}</button>;}",
        "function Square({ value }) {  return <button className=\"square\">{value}</button>;}",
        "export default function Board() {  return (    <>      <div className=\"board-row\">        <Square value=\"1\" />        <Square value=\"2\" />        <Square value=\"3\" />      </div>      <div className=\"board-row\">        <Square value=\"4\" />        <Square value=\"5\" />        <Square value=\"6\" />      </div>      <div className=\"board-row\">        <Square value=\"7\" />        <Square value=\"8\" />        <Square value=\"9\" />      </div>    </>  );}",
        "export default function Board() {  return (    <>      <div className=\"board-row\">        <Square value=\"1\" />        <Square value=\"2\" />        <Square value=\"3\" />      </div>      <div className=\"board-row\">        <Square value=\"4\" />        <Square value=\"5\" />        <Square value=\"6\" />      </div>      <div className=\"board-row\">        <Square value=\"7\" />        <Square value=\"8\" />        <Square value=\"9\" />      </div>    </>  );}",
        "function Square({ value }) {\n  return <button className=\"square\">{value}</button>;\n}\n\nexport default function Board() {\n  return (\n    <>\n      <div className=\"board-row\">\n        <Square value=\"1\" />\n        <Square value=\"2\" />\n        <Square value=\"3\" />\n      </div>\n      <div className=\"board-row\">\n        <Square value=\"4\" />\n        <Square value=\"5\" />\n        <Square value=\"6\" />\n      </div>\n      <div className=\"board-row\">\n        <Square value=\"7\" />\n        <Square value=\"8\" />\n        <Square value=\"9\" />\n      </div>\n    </>\n  );\n}",
        "handleClick",
        "function Square({ value }) {  function handleClick() {    console.log('clicked!');  }  return (    <button      className=\"square\"      onClick={handleClick}    >      {value}    </button>  );}",
        "function Square({ value }) {  function handleClick() {    console.log('clicked!');  }  return (    <button      className=\"square\"      onClick={handleClick}    >      {value}    </button>  );}",
        "import { useState } from 'react';function Square() {  const [value, setValue] = useState(null);  function handleClick() {    //...",
        "import { useState } from 'react';function Square() {  const [value, setValue] = useState(null);  function handleClick() {    //...",
        "// ...export default function Board() {  return (    <>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>    </>  );}",
        "// ...export default function Board() {  return (    <>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>      <div className=\"board-row\">        <Square />        <Square />        <Square />      </div>    </>  );}",
        "console.log(\"clicked!\");",
        "setValue('X');",
        "function Square() {  const [value, setValue] = useState(null);  function handleClick() {    setValue('X');  }  return (    <button      className=\"square\"      onClick={handleClick}    >      {value}    </button>  );}",
        "function Square() {  const [value, setValue] = useState(null);  function handleClick() {    setValue('X');  }  return (    <button      className=\"square\"      onClick={handleClick}    >      {value}    </button>  );}",
        "import { useState } from 'react';\n\nfunction Square() {\n  const [value, setValue] = useState(null);\n\n  function handleClick() {\n    setValue('X');\n  }\n\n  return (\n    <button\n      className=\"square\"\n      onClick={handleClick}\n    >\n      {value}\n    </button>\n  );\n}\n\nexport default function Board() {\n  return (\n    <>\n      <div className=\"board-row\">\n        <Square />\n        <Square />\n        <Square />\n      </div>\n      <div className=\"board-row\">\n        <Square />\n        <Square />\n        <Square />\n      </div>\n      <div className=\"board-row\">\n        <Square />\n        <Square />\n        <Square />\n      </div>\n    </>\n  );\n}",
        "// ...export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    // ...  );}",
        "// ...export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    // ...  );}",
        "Array(9).fill(null)",
        "['O', null, 'X', 'X', 'X', 'O', 'O', null, null]",
        "['O', null, 'X', 'X', 'X', 'O', 'O', null, null]",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} />        <Square value={squares[1]} />        <Square value={squares[2]} />      </div>      <div className=\"board-row\">        <Square value={squares[3]} />        <Square value={squares[4]} />        <Square value={squares[5]} />      </div>      <div className=\"board-row\">        <Square value={squares[6]} />        <Square value={squares[7]} />        <Square value={squares[8]} />      </div>    </>  );}",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} />        <Square value={squares[1]} />        <Square value={squares[2]} />      </div>      <div className=\"board-row\">        <Square value={squares[3]} />        <Square value={squares[4]} />        <Square value={squares[5]} />      </div>      <div className=\"board-row\">        <Square value={squares[6]} />        <Square value={squares[7]} />        <Square value={squares[8]} />      </div>    </>  );}",
        "function Square({value}) {  return <button className=\"square\">{value}</button>;}",
        "function Square({value}) {  return <button className=\"square\">{value}</button>;}",
        "import { useState } from 'react';\n\nfunction Square({ value }) {\n  return <button className=\"square\">{value}</button>;\n}\n\nexport default function Board() {\n  const [squares, setSquares] = useState(Array(9).fill(null));\n  return (\n    <>\n      <div className=\"board-row\">\n        <Square value={squares[0]} />\n        <Square value={squares[1]} />\n        <Square value={squares[2]} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} />\n        <Square value={squares[4]} />\n        <Square value={squares[5]} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} />\n        <Square value={squares[7]} />\n        <Square value={squares[8]} />\n      </div>\n    </>\n  );\n}",
        "onSquareClick",
        "function Square({ value }) {  return (    <button className=\"square\" onClick={onSquareClick}>      {value}    </button>  );}",
        "function Square({ value }) {  return (    <button className=\"square\" onClick={onSquareClick}>      {value}    </button>  );}",
        "onSquareClick",
        "function Square({ value, onSquareClick }) {  return (    <button className=\"square\" onClick={onSquareClick}>      {value}    </button>  );}",
        "function Square({ value, onSquareClick }) {  return (    <button className=\"square\" onClick={onSquareClick}>      {value}    </button>  );}",
        "onSquareClick",
        "handleClick",
        "onSquareClick",
        "handleClick",
        "onSquareClick",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={handleClick} />        //...  );}",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={handleClick} />        //...  );}",
        "handleClick",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick() {    const nextSquares = squares.slice();    nextSquares[0] = \"X\";    setSquares(nextSquares);  }  return (    // ...  )}",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick() {    const nextSquares = squares.slice();    nextSquares[0] = \"X\";    setSquares(nextSquares);  }  return (    // ...  )}",
        "handleClick",
        "nextSquares",
        "handleClick",
        "nextSquares",
        "handleClick",
        "handleClick",
        "handleClick",
        "handleClick",
        "handleClick",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    nextSquares[i] = \"X\";    setSquares(nextSquares);  }  return (    // ...  )}",
        "export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    nextSquares[i] = \"X\";    setSquares(nextSquares);  }  return (    // ...  )}",
        "handleClick",
        "onSquareClick",
        "handleClick(0)",
        "<Square value={squares[0]} onSquareClick={handleClick(0)} />",
        "<Square value={squares[0]} onSquareClick={handleClick(0)} />",
        "handleClick(0)",
        "handleClick(0)",
        "handleClick(0)",
        "onSquareClick={handleClick}",
        "handleClick",
        "handleClick(0)",
        "handleClick",
        "handleFirstSquareClick",
        "handleClick(0)",
        "handleSecondSquareClick",
        "handleClick(1)",
        "onSquareClick={handleFirstSquareClick}",
        "export default function Board() {  // ...  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        // ...  );}",
        "export default function Board() {  // ...  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        // ...  );}",
        "() => handleClick(0)",
        "handleClick(0)",
        "handleClick",
        "handleClick",
        "export default function Board() {  // ...  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />      </div>      <div className=\"board-row\">        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />      </div>      <div className=\"board-row\">        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />      </div>    </>  );};",
        "export default function Board() {  // ...  return (    <>      <div className=\"board-row\">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />      </div>      <div className=\"board-row\">        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />      </div>      <div className=\"board-row\">        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />      </div>    </>  );};",
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nexport default function Board() {\n  const [squares, setSquares] = useState(Array(9).fill(null));\n\n  function handleClick(i) {\n    const nextSquares = squares.slice();\n    nextSquares[i] = 'X';\n    setSquares(nextSquares);\n  }\n\n  return (\n    <>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}",
        "onSquareClick",
        "handleClick",
        "handleClick",
        "onSquareClick",
        "handleClick",
        "onSomething",
        "handleSomething",
        "handleClick",
        "const squares = [null, null, null, null, null, null, null, null, null];squares[0] = 'X';// Now `squares` is [\"X\", null, null, null, null, null, null, null, null];",
        "const squares = [null, null, null, null, null, null, null, null, null];squares[0] = 'X';// Now `squares` is [\"X\", null, null, null, null, null, null, null, null];",
        "const squares = [null, null, null, null, null, null, null, null, null];const nextSquares = ['X', null, null, null, null, null, null, null, null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`",
        "const squares = [null, null, null, null, null, null, null, null, null];const nextSquares = ['X', null, null, null, null, null, null, null, null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`",
        "function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  // ...}",
        "function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  // ...}",
        "handleClick",
        "export default function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = \"X\";    } else {      nextSquares[i] = \"O\";    }    setSquares(nextSquares);    setXIsNext(!xIsNext);  }  return (    //...  );}",
        "export default function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = \"X\";    } else {      nextSquares[i] = \"O\";    }    setSquares(nextSquares);    setXIsNext(!xIsNext);  }  return (    //...  );}",
        "handleClick",
        "function handleClick(i) {  if (squares[i]) {    return;  }  const nextSquares = squares.slice();  //...}",
        "function handleClick(i) {  if (squares[i]) {    return;  }  const nextSquares = squares.slice();  //...}",
        "import { useState } from 'react';\n\nfunction Square({value, onSquareClick}) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nexport default function Board() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [squares, setSquares] = useState(Array(9).fill(null));\n\n  function handleClick(i) {\n    if (squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    setSquares(nextSquares);\n    setXIsNext(!xIsNext);\n  }\n\n  return (\n    <>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}",
        "calculateWinner",
        "calculateWinner",
        "export default function Board() {  //...}function calculateWinner(squares) {  const lines = [    [0, 1, 2],    [3, 4, 5],    [6, 7, 8],    [0, 3, 6],    [1, 4, 7],    [2, 5, 8],    [0, 4, 8],    [2, 4, 6]  ];  for (let i = 0; i < lines.length; i++) {    const [a, b, c] = lines[i];    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {      return squares[a];    }  }  return null;}",
        "export default function Board() {  //...}function calculateWinner(squares) {  const lines = [    [0, 1, 2],    [3, 4, 5],    [6, 7, 8],    [0, 3, 6],    [1, 4, 7],    [2, 5, 8],    [0, 4, 8],    [2, 4, 6]  ];  for (let i = 0; i < lines.length; i++) {    const [a, b, c] = lines[i];    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {      return squares[a];    }  }  return null;}",
        "calculateWinner",
        "calculateWinner(squares)",
        "handleClick",
        "function handleClick(i) {  if (squares[i] || calculateWinner(squares)) {    return;  }  const nextSquares = squares.slice();  //...}",
        "function handleClick(i) {  if (squares[i] || calculateWinner(squares)) {    return;  }  const nextSquares = squares.slice();  //...}",
        "export default function Board() {  // ...  const winner = calculateWinner(squares);  let status;  if (winner) {    status = \"Winner: \" + winner;  } else {    status = \"Next player: \" + (xIsNext ? \"X\" : \"O\");  }  return (    <>      <div className=\"status\">{status}</div>      <div className=\"board-row\">        // ...  )}",
        "export default function Board() {  // ...  const winner = calculateWinner(squares);  let status;  if (winner) {    status = \"Winner: \" + winner;  } else {    status = \"Next player: \" + (xIsNext ? \"X\" : \"O\");  }  return (    <>      <div className=\"status\">{status}</div>      <div className=\"board-row\">        // ...  )}",
        "import { useState } from 'react';\n\nfunction Square({value, onSquareClick}) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nexport default function Board() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [squares, setSquares] = useState(Array(9).fill(null));\n\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    setSquares(nextSquares);\n    setXIsNext(!xIsNext);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "[  // Before first move  [null, null, null, null, null, null, null, null, null],  // After first move  [null, null, null, null, 'X', null, null, null, null],  // After second move  [null, null, null, null, 'X', null, null, null, 'O'],  // ...]",
        "[  // Before first move  [null, null, null, null, null, null, null, null, null],  // After first move  [null, null, null, null, 'X', null, null, null, null],  // After second move  [null, null, null, null, 'X', null, null, null, 'O'],  // ...]",
        "export default",
        "function Board() {  // ...}export default function Game() {  return (    <div className=\"game\">      <div className=\"game-board\">        <Board />      </div>      <div className=\"game-info\">        <ol>{/*TODO*/}</ol>      </div>    </div>  );}",
        "function Board() {  // ...}export default function Game() {  return (    <div className=\"game\">      <div className=\"game-board\">        <Board />      </div>      <div className=\"game-info\">        <ol>{/*TODO*/}</ol>      </div>    </div>  );}",
        "export default",
        "function Board() {",
        "function Game() {",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  // ...",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  // ...",
        "[Array(9).fill(null)]",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  // ...",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  // ...",
        "currentSquares",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    // TODO  }  return (    <div className=\"game\">      <div className=\"game-board\">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />        //...  )}",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    // TODO  }  return (    <div className=\"game\">      <div className=\"game-board\">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />        //...  )}",
        "function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    //...  }  // ...}",
        "function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    //...  }  // ...}",
        "handleClick",
        "function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    if (calculateWinner(squares) || squares[i]) {      return;    }    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = \"X\";    } else {      nextSquares[i] = \"O\";    }    onPlay(nextSquares);  }  //...}",
        "function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    if (calculateWinner(squares) || squares[i]) {      return;    }    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = \"X\";    } else {      nextSquares[i] = \"O\";    }    onPlay(nextSquares);  }  //...}",
        "export default function Game() {  //...  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  //...}",
        "export default function Game() {  //...  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  //...}",
        "[...history, nextSquares]",
        "nextSquares",
        "[[null,null,null], [\"X\",null,null]]",
        "nextSquares",
        "[\"X\",null,\"O\"]",
        "[...history, nextSquares]",
        "[[null,null,null], [\"X\",null,null], [\"X\",null,\"O\"]]",
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const currentSquares = history[history.length - 1];\n\n  function handlePlay(nextSquares) {\n    setHistory([...history, nextSquares]);\n    setXIsNext(!xIsNext);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{/*TODO*/}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "[1, 2, 3].map((x) => x * 2) // [2, 4, 6]",
        "[1, 2, 3].map((x) => x * 2) // [2, 4, 6]",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  function jumpTo(nextMove) {    // TODO  }  const moves = history.map((squares, move) => {    let description;    if (move > 0) {      description = 'Go to move #' + move;    } else {      description = 'Go to game start';    }    return (      <li>        <button onClick={() => jumpTo(move)}>{description}</button>      </li>    );  });  return (    <div className=\"game\">      <div className=\"game-board\">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />      </div>      <div className=\"game-info\">        <ol>{moves}</ol>      </div>    </div>  );}",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  function jumpTo(nextMove) {    // TODO  }  const moves = history.map((squares, move) => {    let description;    if (move > 0) {      description = 'Go to move #' + move;    } else {      description = 'Go to game start';    }    return (      <li>        <button onClick={() => jumpTo(move)}>{description}</button>      </li>    );  });  return (    <div className=\"game\">      <div className=\"game-board\">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />      </div>      <div className=\"game-info\">        <ol>{moves}</ol>      </div>    </div>  );}",
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const currentSquares = history[history.length - 1];\n\n  function handlePlay(nextSquares) {\n    setHistory([...history, nextSquares]);\n    setXIsNext(!xIsNext);\n  }\n\n  function jumpTo(nextMove) {\n    // TODO\n  }\n\n  const moves = history.map((squares, move) => {\n    let description;\n    if (move > 0) {\n      description = 'Go to move #' + move;\n    } else {\n      description = 'Go to game start';\n    }\n    return (\n      <li>\n        <button onClick={() => jumpTo(move)}>{description}</button>\n      </li>\n    );\n  });\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{moves}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "<li>Alexa: 7 tasks left</li><li>Ben: 5 tasks left</li>",
        "<li>Alexa: 7 tasks left</li><li>Ben: 5 tasks left</li>",
        "<li>Ben: 9 tasks left</li><li>Claudia: 8 tasks left</li><li>Alexa: 5 tasks left</li>",
        "<li>Ben: 9 tasks left</li><li>Claudia: 8 tasks left</li><li>Alexa: 5 tasks left</li>",
        "<li key={user.id}>  {user.name}: {user.taskCount} tasks left</li>",
        "<li key={user.id}>  {user.name}: {user.taskCount} tasks left</li>",
        "<li key={move}>",
        "const moves = history.map((squares, move) => {  //...  return (    <li key={move}>      <button onClick={() => jumpTo(move)}>{description}</button>    </li>  );});",
        "const moves = history.map((squares, move) => {  //...  return (    <li key={move}>      <button onClick={() => jumpTo(move)}>{description}</button>    </li>  );});",
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const currentSquares = history[history.length - 1];\n\n  function handlePlay(nextSquares) {\n    setHistory([...history, nextSquares]);\n    setXIsNext(!xIsNext);\n  }\n\n  function jumpTo(nextMove) {\n    // TODO\n  }\n\n  const moves = history.map((squares, move) => {\n    let description;\n    if (move > 0) {\n      description = 'Go to move #' + move;\n    } else {\n      description = 'Go to game start';\n    }\n    return (\n      <li key={move}>\n        <button onClick={() => jumpTo(move)}>{description}</button>\n      </li>\n    );\n  });\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{moves}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "currentMove",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[history.length - 1];  //...}",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[history.length - 1];  //...}",
        "currentMove",
        "currentMove",
        "export default function Game() {  // ...  function jumpTo(nextMove) {    setCurrentMove(nextMove);    setXIsNext(nextMove % 2 === 0);  }  //...}",
        "export default function Game() {  // ...  function jumpTo(nextMove) {    setCurrentMove(nextMove);    setXIsNext(nextMove % 2 === 0);  }  //...}",
        "nextSquares",
        "history.slice(0, currentMove + 1)",
        "currentMove",
        "function handlePlay(nextSquares) {  const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];  setHistory(nextHistory);  setCurrentMove(nextHistory.length - 1);  setXIsNext(!xIsNext);}",
        "function handlePlay(nextSquares) {  const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];  setHistory(nextHistory);  setCurrentMove(nextHistory.length - 1);  setXIsNext(!xIsNext);}",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[currentMove];  // ...}",
        "export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[currentMove];  // ...}",
        "import { useState } from 'react';\n\nfunction Square({value, onSquareClick}) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [xIsNext, setXIsNext] = useState(true);\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const [currentMove, setCurrentMove] = useState(0);\n  const currentSquares = history[currentMove];\n\n  function handlePlay(nextSquares) {\n    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\n    setHistory(nextHistory);\n    setCurrentMove(nextHistory.length - 1);\n    setXIsNext(!xIsNext);\n  }\n\n  function jumpTo(nextMove) {\n    setCurrentMove(nextMove);\n    setXIsNext(nextMove % 2 === 0);\n  }\n\n  const moves = history.map((squares, move) => {\n    let description;\n    if (move > 0) {\n      description = 'Go to move #' + move;\n    } else {\n      description = 'Go to game start';\n    }\n    return (\n      <li key={move}>\n        <button onClick={() => jumpTo(move)}>{description}</button>\n      </li>\n    );\n  });\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{moves}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}",
        "xIsNext === true",
        "currentMove",
        "xIsNext === false",
        "currentMove",
        "currentMove",
        "currentMove",
        "export default function Game() {  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const xIsNext = currentMove % 2 === 0;  const currentSquares = history[currentMove];  function handlePlay(nextSquares) {    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];    setHistory(nextHistory);    setCurrentMove(nextHistory.length - 1);  }  function jumpTo(nextMove) {    setCurrentMove(nextMove);  }  // ...}",
        "export default function Game() {  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const xIsNext = currentMove % 2 === 0;  const currentSquares = history[currentMove];  function handlePlay(nextSquares) {    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];    setHistory(nextHistory);    setCurrentMove(nextHistory.length - 1);  }  function jumpTo(nextMove) {    setCurrentMove(nextMove);  }  // ...}",
        "currentMove",
        "import { useState } from 'react';\n\nfunction Square({ value, onSquareClick }) {\n  return (\n    <button className=\"square\" onClick={onSquareClick}>\n      {value}\n    </button>\n  );\n}\n\nfunction Board({ xIsNext, squares, onPlay }) {\n  function handleClick(i) {\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    const nextSquares = squares.slice();\n    if (xIsNext) {\n      nextSquares[i] = 'X';\n    } else {\n      nextSquares[i] = 'O';\n    }\n    onPlay(nextSquares);\n  }\n\n  const winner = calculateWinner(squares);\n  let status;\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <>\n      <div className=\"status\">{status}</div>\n      <div className=\"board-row\">\n        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />\n        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />\n        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />\n        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />\n        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />\n      </div>\n      <div className=\"board-row\">\n        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />\n        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />\n        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />\n      </div>\n    </>\n  );\n}\n\nexport default function Game() {\n  const [history, setHistory] = useState([Array(9).fill(null)]);\n  const [currentMove, setCurrentMove] = useState(0);\n  const xIsNext = currentMove % 2 === 0;\n  const currentSquares = history[currentMove];\n\n  function handlePlay(nextSquares) {\n    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];\n    setHistory(nextHistory);\n    setCurrentMove(nextHistory.length - 1);\n  }\n\n  function jumpTo(nextMove) {\n    setCurrentMove(nextMove);\n  }\n\n  const moves = history.map((squares, move) => {\n    let description;\n    if (move > 0) {\n      description = 'Go to move #' + move;\n    } else {\n      description = 'Go to game start';\n    }\n    return (\n      <li key={move}>\n        <button onClick={() => jumpTo(move)}>{description}</button>\n      </li>\n    );\n  });\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />\n      </div>\n      <div className=\"game-info\">\n        <ol>{moves}</ol>\n      </div>\n    </div>\n  );\n}\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}"
      ],
      "chunks": [
        {
          "content": "Learn ReactQuick StartTutorial: Tic-Tac-ToeYou will build a small tic-tac-toe game during this tutorial This tutorial does not assume any existing React knowledge The techniques youll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React NoteThis tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "If you prefer learning each concept step by step, start with Describing the UI The tutorial is divided into several sections: Setup for the tutorial will give you a starting point to follow the tutorial Overview will teach you the fundamentals of React: components, props, and state Completing the game will teach you the most common techniques in React development Adding time travel will give you a deeper insight into the unique strengths of React What are you building",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "In this tutorial, youll build an interactive tic-tac-toe game with React You can see what it will look like when youre finished here: App jsApp js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [ history slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more If the code doesnt make sense to you yet, or if you are unfamiliar with the codes syntax, dont worry The goal of this tutorial is to help you understand React and its syntax We recommend that you check out the tic-tac-toe game above before continuing with the tutorial",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "One of the features that youll notice is that there is a numbered list to the right of the games board This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses Once youve played around with the finished tic-tac-toe game, keep scrolling Youll start with a simpler template in this tutorial Our next step is to set you up so that you can start building the game",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "Setup for the tutorial In the live code editor below, click Fork in the top-right corner to open the editor in a new tab using the website CodeSandbox CodeSandbox lets you write code in your browser and preview how your users will see the app youve created The new tab should display an empty square and the starter code for this tutorial App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "js ResetForkexport default function Square() { return button className=\"square\"X/button; } NoteYou can also follow this tutorial using your local development environment To do this, you need to: Install Node",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "js In the CodeSandbox tab you opened earlier, press the top-left corner button to open the menu, and then choose Download Sandbox in that menu to download an archive of the files locally Unzip the archive, then open a terminal and cd to the directory you unzipped Install the dependencies with npm install Run npm start to start a local server and follow the prompts to view the code running in a browser If you get stuck, dont let this stop you",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "Follow along online instead and try a local setup again later Overview Now that youre set up, lets get an overview of React Inspecting the starter code In CodeSandbox youll see three main sections: The Files section with a list of files like App js, index js, styles css and a folder called public The code editor where youll see the source code of your selected file The browser section where youll see how the code youve written will be displayed The App",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "js file should be selected in the Files section The contents of that file in the code editor should be: export default function Square() { return button className=\"square\"X/button;} The browser section should be displaying a square with an X in it like this: Now lets have a look at the files in the starter code App js The code in App js creates a component In React, a component is a piece of reusable code that represents a part of a user interface",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Components are used to render, manage, and update the UI elements in your application Lets look at the component line by line to see whats going on: export default function Square() { return button className=\"square\"X/button;} The first line defines a function called Square The export JavaScript keyword makes this function accessible outside of this file The default keyword tells other files using your code that its the main function in your file",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "export default function Square() { return button className=\"square\"X/button;} The second line returns a button The return JavaScript keyword means whatever comes after is returned as a value to the caller of the function button is a JSX element A JSX element is a combination of JavaScript code and HTML tags that describes what youd like to display className=\"square\" is a button property or prop that tells CSS how to style the button",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "X is the text displayed inside of the button and /button closes the JSX element to indicate that any following content shouldnt be placed inside the button styles css Click on the file labeled styles css in the Files section of CodeSandbox This file defines the styles for your React app The first two CSS selectors (* and body) define the style of large parts of your app while the square selector defines the style of any component where the className property is set to square",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "In your code, that would match the button from your Square component in the App js file index js Click on the file labeled index js in the Files section of CodeSandbox You wont be editing this file during the tutorial but it is the bridge between the component you created in the App js file and the web browser import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';import ' /styles css';import App from '",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "/App'; Lines 1-5 bring all the necessary pieces together: React Reacts library to talk to web browsers (React DOM) the styles for your components the component you created in App js The remainder of the file brings all the pieces together and injects the final product into index html in the public folder Building the board Lets get back to App js This is where youll spend the rest of the tutorial Currently the board is only a single square, but you need nine",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "If you just try and copy paste your square to make two squares like this: export default function Square() { return button className=\"square\"X/buttonbutton className=\"square\"X/button;} Youll get this error: Console/src/App js: Adjacent JSX elements must be wrapped in an enclosing tag Did you want a JSX Fragment / React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "To fix this you can use Fragments ( and /) to wrap multiple adjacent JSX elements like this: export default function Square() { return (  button className=\"square\"X/button button className=\"square\"X/button / );} Now you should see: Great Now you just need to copy-paste a few times to add nine squares and Oh no The squares are all in a single line, not in a grid like you need for our board To fix this youll need to group your squares into rows with divs and add some CSS classes",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "While youre at it, youll give each square a number to make sure you know where each square is displayed In the App",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "js file, update the Square component to look like this: export default function Square() { return (  div className=\"board-row\" button className=\"square\"1/button button className=\"square\"2/button button className=\"square\"3/button /div div className=\"board-row\" button className=\"square\"4/button button className=\"square\"5/button button className=\"square\"6/button /div div className=\"board-row\" button className=\"square\"7/button button className=\"square\"8/button button className=\"square\"9/button /div / );} The CSS defined in styles",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "css styles the divs with the className of board-row Now that youve grouped your components into rows with the styled divs you have your tic-tac-toe board: But you now have a problem Your component named Square, really isnt a square anymore Lets fix that by changing the name to Board: export default function Board() { // } At this point your code should look something like this: App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "js ResetForkexport default function Board() { return (  div className=\"board-row\" button className=\"square\"1/button button className=\"square\"2/button button className=\"square\"3/button /div div className=\"board-row\" button className=\"square\"4/button button className=\"square\"5/button button className=\"square\"6/button /div div className=\"board-row\" button className=\"square\"7/button button className=\"square\"8/button button className=\"square\"9/button /div / ); } Show more NotePsssst Thats a lot to type",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "Its okay to copy and paste code from this page However, if youre up for a little challenge, we recommend only copying code that youve manually typed at least once yourself Passing data through props Next, youll want to change the value of a square from empty to X when the user clicks on the square With how youve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "Instead of copy-pasting, Reacts component architecture allows you to create a reusable component to avoid messy, duplicated code First, you are going to copy the line defining your first square (button className=\"square\"1/button) from your Board component into a new Square component: function Square() { return button className=\"square\"1/button;}export default function Board() { // } Then youll update the Board component to render that Square component using JSX syntax: //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / );} Note how unlike the browser divs, your own components Board and Square must start with a capital letter Lets take a look: Oh no You lost the numbered squares you had before Now each square says 1",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "To fix this, you will use props to pass the value each square should have from the parent component (Board) to its child (Square) Update the Square component to read the value prop that youll pass from the Board: function Square({ value }) { return button className=\"square\"1/button;} function Square({ value }) indicates the Square component can be passed a prop called value Now you want to display that value instead of 1 inside every square",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "Try doing it like this: function Square({ value }) { return button className=\"square\"value/button;} Oops, this is not what you wanted: You wanted to render the JavaScript variable called value from your component, not the word value To escape into JavaScript from JSX, you need curly braces",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "Add curly braces around value in JSX like so: function Square({ value }) { return button className=\"square\"{value}/button;} For now, you should see an empty board: This is because the Board component hasnt passed the value prop to each Square component it renders yet",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_30"
        },
        {
          "content": "To fix it youll add the value prop to each Square component rendered by the Board component: export default function Board() { return (  div className=\"board-row\" Square value=\"1\" / Square value=\"2\" / Square value=\"3\" / /div div className=\"board-row\" Square value=\"4\" / Square value=\"5\" / Square value=\"6\" / /div div className=\"board-row\" Square value=\"7\" / Square value=\"8\" / Square value=\"9\" / /div / );} Now you should see a grid of numbers again: Your updated code should look like this: App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_31"
        },
        {
          "content": "js ResetForkfunction Square({ value }) { return button className=\"square\"{value}/button; } export default function Board() { return (  div className=\"board-row\" Square value=\"1\" / Square value=\"2\" / Square value=\"3\" / /div div className=\"board-row\" Square value=\"4\" / Square value=\"5\" / Square value=\"6\" / /div div className=\"board-row\" Square value=\"7\" / Square value=\"8\" / Square value=\"9\" / /div / ); } Show more Making an interactive component Lets fill the Square component with an X when you click it",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_32"
        },
        {
          "content": "Declare a function called handleClick inside of the Square Then, add onClick to the props of the button JSX element returned from the Square: function Square({ value }) { function handleClick() { console log('clicked '); } return ( button className=\"square\" onClick={handleClick}  {value} /button );} If you click on a square now, you should see a log saying \"clicked \" in the Console tab at the bottom of the Browser section in CodeSandbox Clicking the square more than once will log \"clicked \" again",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_33"
        },
        {
          "content": "Repeated console logs with the same message will not create more lines in the console Instead, you will see an incrementing counter next to your first \"clicked \" log NoteIf you are following this tutorial using your local development environment, you need to open your browsers Console For example, if you use the Chrome browser, you can view the Console with the keyboard shortcut Shift + Ctrl + J (on Windows/Linux) or Option +  + J (on macOS)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_34"
        },
        {
          "content": "As a next step, you want the Square component to remember that it got clicked, and fill it with an X mark To remember things, components use state React provides a special function called useState that you can call from your component to let it remember things Lets store the current value of the Square in state, and change it when the Square is clicked Import useState at the top of the file Remove the value prop from the Square component",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_35"
        },
        {
          "content": "Instead, add a new line at the start of the Square that calls useState Have it return a state variable called value: import { useState } from 'react';function Square() { const [value, setValue] = useState(null); function handleClick() { // value stores the value and setValue is a function that can be used to change the value The null passed to useState is used as the initial value for this state variable, so value here starts off equal to null",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_36"
        },
        {
          "content": "Since the Square component no longer accepts props anymore, youll remove the value prop from all nine of the Square components created by the Board component: // export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / );} Now youll change Square to display an X when clicked Replace the console log(\"clicked",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_37"
        },
        {
          "content": "\"); event handler with setValue('X'); Now your Square component looks like this: function Square() { const [value, setValue] = useState(null); function handleClick() { setValue('X'); } return ( button className=\"square\" onClick={handleClick}  {value} /button );} By calling this set function from an onClick handler, youre telling React to re-render that Square whenever its button is clicked After the update, the Squares value will be 'X', so youll see the X on the game board",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_38"
        },
        {
          "content": "Click on any Square, and X should show up: Each Square has its own state: the value stored in each Square is completely independent of the others When you call a set function in a component, React automatically updates the child components inside too After youve made the above changes, your code will look like this: App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_39"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; function Square() { const [value, setValue] = useState(null); function handleClick() { setValue('X'); } return ( button className=\"square\" onClick={handleClick}  {value} /button ); } export default function Board() { return (  div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div div className=\"board-row\" Square / Square / Square / /div / ); } Show more React Developer Tools React DevTools let you check the props and the state of your React components",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_40"
        },
        {
          "content": "You can find the React DevTools tab at the bottom of the browser section in CodeSandbox: To inspect a particular component on the screen, use the button in the top left corner of React DevTools: NoteFor local development, React DevTools is available as a Chrome, Firefox, and Edge browser extension Install it, and the Components tab will appear in your browser Developer Tools for sites using React Completing the game By this point, you have all the basic building blocks for your tic-tac-toe game",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_41"
        },
        {
          "content": "To have a complete game, you now need to alternate placing Xs and Os on the board, and you need a way to determine a winner Lifting state up Currently, each Square component maintains a part of the games state To check for a winner in a tic-tac-toe game, the Board would need to somehow know the state of each of the 9 Square components How would you approach that At first, you might guess that the Board needs to ask each Square for that Squares state",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_42"
        },
        {
          "content": "Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor Instead, the best approach is to store the games state in the parent Board component instead of in each Square The Board component can tell each Square what to display by passing a prop, like you did when you passed a number to each Square",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_43"
        },
        {
          "content": "To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead The parent component can pass that state back down to the children via props This keeps the child components in sync with each other and with their parent Lifting state into a parent component is common when React components are refactored Lets take this opportunity to try it out",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_44"
        },
        {
          "content": "Edit the Board component so that it declares a state variable named squares that defaults to an array of 9 nulls corresponding to the 9 squares: // export default function Board() { const [squares, setSquares] = useState(Array(9) fill(null)); return ( // );} Array(9) fill(null) creates an array with nine elements and sets each of them to null The useState() call around it declares a squares state variable thats initially set to that array",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_45"
        },
        {
          "content": "Each entry in the array corresponds to the value of a square When you fill the board in later, the squares array will look like this: ['O', null, 'X', 'X', 'X', 'O', 'O', null, null] Now your Board component needs to pass the value prop down to each Square that it renders: export default function Board() { const [squares, setSquares] = useState(Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_46"
        },
        {
          "content": "fill(null)); return (  div className=\"board-row\" Square value={squares[0]} / Square value={squares[1]} / Square value={squares[2]} / /div div className=\"board-row\" Square value={squares[3]} / Square value={squares[4]} / Square value={squares[5]} / /div div className=\"board-row\" Square value={squares[6]} / Square value={squares[7]} / Square value={squares[8]} / /div / );} Next, youll edit the Square component to receive the value prop from the Board component",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_47"
        },
        {
          "content": "This will require removing the Square components own stateful tracking of value and the buttons onClick prop: function Square({value}) { return button className=\"square\"{value}/button;} At this point you should see an empty tic-tac-toe board: And your code should look like this: App jsApp js ResetForkimport { useState } from 'react'; function Square({ value }) { return button className=\"square\"{value}/button; } export default function Board() { const [squares, setSquares] = useState(Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_48"
        },
        {
          "content": "fill(null)); return (  div className=\"board-row\" Square value={squares[0]} / Square value={squares[1]} / Square value={squares[2]} / /div div className=\"board-row\" Square value={squares[3]} / Square value={squares[4]} / Square value={squares[5]} / /div div className=\"board-row\" Square value={squares[6]} / Square value={squares[7]} / Square value={squares[8]} / /div / ); } Show more Each Square will now receive a value prop that will either be 'X', 'O', or null for empty squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_49"
        },
        {
          "content": "Next, you need to change what happens when a Square is clicked The Board component now maintains which squares are filled Youll need to create a way for the Square to update the Boards state Since state is private to a component that defines it, you cannot update the Boards state directly from Square Instead, youll pass down a function from the Board component to the Square component, and youll have Square call that function when a square is clicked",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_50"
        },
        {
          "content": "Youll start with the function that the Square component will call when it is clicked",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_51"
        },
        {
          "content": "Youll call that function onSquareClick: function Square({ value }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button );} Next, youll add the onSquareClick function to the Square components props: function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button );} Now youll connect the onSquareClick prop to a function in the Board component that youll name handleClick",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_52"
        },
        {
          "content": "To connect onSquareClick to handleClick youll pass a function to the onSquareClick prop of the first Square component: export default function Board() { const [squares, setSquares] = useState(Array(9) fill(null)); return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={handleClick} / //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_53"
        },
        {
          "content": ");} Lastly, you will define the handleClick function inside the Board component to update the squares array holding your boards state: export default function Board() { const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick() { const nextSquares = squares slice(); nextSquares[0] = \"X\"; setSquares(nextSquares); } return ( // )} The handleClick function creates a copy of the squares array (nextSquares) with the JavaScript slice() Array method",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_54"
        },
        {
          "content": "Then, handleClick updates the nextSquares array to add X to the first ([0] index) square Calling the setSquares function lets React know the state of the component has changed This will trigger a re-render of the components that use the squares state (Board) as well as its child components (the Square components that make up the board) NoteJavaScript supports closures which means an inner function (e g handleClick) has access to variables and functions defined in an outer function (e g Board)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_55"
        },
        {
          "content": "The handleClick function can read the squares state and call the setSquares method because they are both defined inside of the Board function Now you can add Xs to the board but only to the upper left square Your handleClick function is hardcoded to update the index for the upper left square (0) Lets update handleClick to be able to update any square",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_56"
        },
        {
          "content": "Add an argument i to the handleClick function that takes the index of the square to update: export default function Board() { const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick(i) { const nextSquares = squares slice(); nextSquares[i] = \"X\"; setSquares(nextSquares); } return ( // )} Next, you will need to pass that i to handleClick",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_57"
        },
        {
          "content": "You could try to set the onSquareClick prop of square to be handleClick(0) directly in the JSX like this, but it wont work: Square value={squares[0]} onSquareClick={handleClick(0)} / Here is why this doesnt work The handleClick(0) call will be a part of rendering the board component Because handleClick(0) alters the state of the board component by calling setSquares, your entire board component will be re-rendered again",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_58"
        },
        {
          "content": "But this runs handleClick(0) again, leading to an infinite loop: ConsoleToo many re-renders React limits the number of renders to prevent an infinite loop Why didnt this problem happen earlier When you were passing onSquareClick={handleClick}, you were passing the handleClick function down as a prop You were not calling it But now you are calling that function right awaynotice the parentheses in handleClick(0)and thats why it runs too early You dont want to call handleClick until the user clicks",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_59"
        },
        {
          "content": "You could fix this by creating a function like handleFirstSquareClick that calls handleClick(0), a function like handleSecondSquareClick that calls handleClick(1), and so on You would pass (rather than call) these functions down as props like onSquareClick={handleFirstSquareClick} This would solve the infinite loop However, defining nine different functions and giving each of them a name is too verbose Instead, lets do this: export default function Board() { //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_60"
        },
        {
          "content": "return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / // );} Notice the new () = syntax Here, () = handleClick(0) is an arrow function, which is a shorter way to define functions When the square is clicked, the code after the = arrow will run, calling handleClick(0) Now you need to update the other eight squares to call handleClick from the arrow functions you pass",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_61"
        },
        {
          "content": "Make sure that the argument for each call of the handleClick corresponds to the index of the correct square: export default function Board() { //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_62"
        },
        {
          "content": "return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / );}; Now you can again add Xs to any square on the board by clicking on them: But this time all the state management is handled by the Board component",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_63"
        },
        {
          "content": "This is what your code should look like: App jsApp js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick(i) { const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_64"
        },
        {
          "content": "slice(); nextSquares[i] = 'X'; setSquares(nextSquares); } return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } Show more Now that your state handling is in the Board component, the parent Board component passes props to the child Square components so that they can be displayed correctly",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_65"
        },
        {
          "content": "When clicking on a Square, the child Square component now asks the parent Board component to update the state of the board When the Boards state changes, both the Board component and every child Square re-renders automatically Keeping the state of all squares in the Board component will allow it to determine the winner in the future",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_66"
        },
        {
          "content": "Lets recap what happens when a user clicks the top left square on your board to add an X to it: Clicking on the upper left square runs the function that the button received as its onClick prop from the Square The Square component received that function as its onSquareClick prop from the Board The Board component defined that function directly in the JSX It calls handleClick with an argument of 0 handleClick uses the argument (0) to update the first element of the squares array from null to X",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_67"
        },
        {
          "content": "The squares state of the Board component was updated, so the Board and all of its children re-render This causes the value prop of the Square component with index 0 to change from null to X In the end the user sees that the upper left square has changed from empty to having an X after clicking it NoteThe DOM button elements onClick attribute has a special meaning to React because it is a built-in component For custom components like Square, the naming is up to you",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_68"
        },
        {
          "content": "You could give any name to the Squares onSquareClick prop or Boards handleClick function, and the code would work the same In React, its conventional to use onSomething names for props which represent events and handleSomething for the function definitions which handle those events Why immutability is important Note how in handleClick, you call slice() to create a copy of the squares array instead of modifying the existing array",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_69"
        },
        {
          "content": "To explain why, we need to discuss immutability and why immutability is important to learn There are generally two approaches to changing data The first approach is to mutate the data by directly changing the datas values The second approach is to replace the data with a new copy which has the desired changes",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_70"
        },
        {
          "content": "Here is what it would look like if you mutated the squares array: const squares = [null, null, null, null, null, null, null, null, null];squares[0] = 'X';// Now `squares` is [\"X\", null, null, null, null, null, null, null, null]; And here is what it would look like if you changed data without mutating the squares array: const squares = [null, null, null, null, null, null, null, null, null];const nextSquares = ['X', null, null, null, null, null, null, null, null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null` The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_71"
        },
        {
          "content": "Immutability makes complex features much easier to implement Later in this tutorial, you will implement a time travel feature that lets you review the games history and jump back to past moves This functionality isnt specific to gamesan ability to undo and redo certain actions is a common requirement for apps Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later There is also another benefit of immutability",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_72"
        },
        {
          "content": "By default, all child components re-render automatically when the state of a parent component changes This includes even the child components that werent affected by the change Although re-rendering is not by itself noticeable to the user (you shouldnt actively try to avoid it ), you might want to skip re-rendering a part of the tree that clearly wasnt affected by it for performance reasons Immutability makes it very cheap for components to compare whether their data has changed or not",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_73"
        },
        {
          "content": "You can learn more about how React chooses when to re-render a component in the memo API reference Taking turns Its now time to fix a major defect in this tic-tac-toe game: the Os cannot be marked on the board Youll set the first move to be X by default Lets keep track of this by adding another piece of state to the Board component: function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9) fill(null)); //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_74"
        },
        {
          "content": "} Each time a player moves, xIsNext (a boolean) will be flipped to determine which player goes next and the games state will be saved Youll update the Boards handleClick function to flip the value of xIsNext: export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick(i) { const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_75"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = \"X\"; } else { nextSquares[i] = \"O\"; } setSquares(nextSquares); setXIsNext( xIsNext); } return ( // );} Now, as you click on different squares, they will alternate between X and O, as they should But wait, theres a problem Try clicking on the same square multiple times: The X is overwritten by an O While this would add a very interesting twist to the game, were going to stick to the original rules for now",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_76"
        },
        {
          "content": "When you mark a square with an X or an O you arent first checking to see if the square already has an X or O value You can fix this by returning early Youll check to see if the square already has an X or an O If the square is already filled, you will return in the handleClick function earlybefore it tries to update the board state function handleClick(i) { if (squares[i]) { return; } const nextSquares = squares slice(); // } Now you can only add Xs or Os to empty squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_77"
        },
        {
          "content": "Here is what your code should look like at this point: App jsApp js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick(i) { if (squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_78"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } setSquares(nextSquares); setXIsNext(",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_79"
        },
        {
          "content": "xIsNext); } return (  div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } Show more Declaring a winner Now that the players can take turns, youll want to show when the game is won and there are no more turns to make",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_80"
        },
        {
          "content": "To do this youll add a helper function called calculateWinner that takes an array of 9 squares, checks for a winner and returns 'X', 'O', or null as appropriate Dont worry too much about the calculateWinner function; its not specific to React: export default function Board() { // }function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_81"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null;} NoteIt does not matter whether you define calculateWinner before or after the Board Lets put it at the end so that you dont have to scroll past it every time you edit your components You will call calculateWinner(squares) in the Board components handleClick function to check if a player has won",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_82"
        },
        {
          "content": "You can perform this check at the same time you check if a user has clicked a square that already has an X or an O Wed like to return early in both cases: function handleClick(i) { if (squares[i]  calculateWinner(squares)) { return; } const nextSquares = squares slice(); // } To let the players know when the game is over, you can display text such as Winner: X or Winner: O To do that youll add a status section to the Board component",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_83"
        },
        {
          "content": "The status will display the winner if the game is over and if the game is ongoing youll display which players turn is next: export default function Board() { // const winner = calculateWinner(squares); let status; if (winner) { status = \"Winner: \" + winner; } else { status = \"Next player: \" + (xIsNext \"X\" : \"O\"); } return (  div className=\"status\"{status}/div div className=\"board-row\" // )} Congratulations You now have a working tic-tac-toe game And youve just learned the basics of React too",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_84"
        },
        {
          "content": "So you are the real winner here Here is what the code should look like: App jsApp js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } export default function Board() { const [xIsNext, setXIsNext] = useState(true); const [squares, setSquares] = useState(Array(9) fill(null)); function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_85"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } setSquares(nextSquares); setXIsNext( xIsNext); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_86"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_87"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Adding time travel As a final exercise, lets make it possible to go back in time to the previous moves in the game Storing a history of moves If you mutated the squares array, implementing time travel would be very difficult However, you used slice() to create a new copy of the squares array after every move, and treated it as immutable",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_88"
        },
        {
          "content": "This will allow you to store every past version of the squares array, and navigate between the turns that have already happened Youll store the past squares arrays in another array called history, which youll store as a new state variable",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_89"
        },
        {
          "content": "The history array represents all board states, from the first to the last move, and has a shape like this: [ // Before first move [null, null, null, null, null, null, null, null, null], // After first move [null, null, null, null, 'X', null, null, null, null], // After second move [null, null, null, null, 'X', null, null, null, 'O'], // ] Lifting state up, again You will now write a new top-level component called Game to display a list of past moves",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_90"
        },
        {
          "content": "Thats where you will place the history state that contains the entire game history Placing the history state into the Game component will let you remove the squares state from its child Board component Just like you lifted state up from the Square component into the Board component, you will now lift it up from the Board into the top-level Game component This gives the Game component full control over the Boards data and lets it instruct the Board to render previous turns from the history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_91"
        },
        {
          "content": "First, add a Game component with export default Have it render the Board component and some markup: function Board() { // }export default function Game() { return ( div className=\"game\" div className=\"game-board\" Board / /div div className=\"game-info\" ol{/*TODO*/}/ol /div /div );} Note that you are removing the export default keywords before the function Board() { declaration and adding them before the function Game() { declaration This tells your index",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_92"
        },
        {
          "content": "js file to use the Game component as the top-level component instead of your Board component The additional divs returned by the Game component are making room for the game information youll add to the board later Add some state to the Game component to track which player is next and the history of moves: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9) fill(null)]); // Notice how [Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_93"
        },
        {
          "content": "fill(null)] is an array with a single item, which itself is an array of 9 nulls To render the squares for the current move, youll want to read the last squares array from the history You dont need useState for thisyou already have enough information to calculate it during rendering: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9) fill(null)]); const currentSquares = history[history length - 1]; //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_94"
        },
        {
          "content": "Next, create a handlePlay function inside the Game component that will be called by the Board component to update the game Pass xIsNext, currentSquares and handlePlay as props to the Board component: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9) fill(null)]); const currentSquares = history[history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_95"
        },
        {
          "content": "length - 1]; function handlePlay(nextSquares) { // TODO } return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / // )} Lets make the Board component fully controlled by the props it receives Change the Board component to take three props: xIsNext, squares, and a new onPlay function that Board can call with the updated squares array when a player makes a move",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_96"
        },
        {
          "content": "Next, remove the first two lines of the Board function that call useState: function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { // } //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_97"
        },
        {
          "content": "} Now replace the setSquares and setXIsNext calls in handleClick in the Board component with a single call to your new onPlay function so the Game component can update the Board when the user clicks a square: function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares slice(); if (xIsNext) { nextSquares[i] = \"X\"; } else { nextSquares[i] = \"O\"; } onPlay(nextSquares); } //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_98"
        },
        {
          "content": "} The Board component is fully controlled by the props passed to it by the Game component You need to implement the handlePlay function in the Game component to get the game working again What should handlePlay do when called Remember that Board used to call setSquares with an updated array; now it passes the updated squares array to onPlay",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_99"
        },
        {
          "content": "The handlePlay function needs to update Games state to trigger a re-render, but you dont have a setSquares function that you can call any moreyoure now using the history state variable to store this information Youll want to update history by appending the updated squares array as a new history entry You also want to toggle xIsNext, just as Board used to do: export default function Game() { // function handlePlay(nextSquares) { setHistory([ history, nextSquares]); setXIsNext( xIsNext); } //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_100"
        },
        {
          "content": "} Here, [ history, nextSquares] creates a new array that contains all the items in history, followed by nextSquares (You can read the history spread syntax as enumerate all the items in history ) For example, if history is [[null,null,null], [\"X\",null,null]] and nextSquares is [\"X\",null,\"O\"], then the new [ history, nextSquares] array will be [[null,null,null], [\"X\",null,null], [\"X\",null,\"O\"]]",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_101"
        },
        {
          "content": "At this point, youve moved the state to live in the Game component, and the UI should be fully working, just as it was before the refactor Here is what the code should look like at this point: App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_102"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_103"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_104"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_105"
        },
        {
          "content": "fill(null)]); const currentSquares = history[history length - 1]; function handlePlay(nextSquares) { setHistory([ history, nextSquares]); setXIsNext(",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_106"
        },
        {
          "content": "xIsNext); } return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{/*TODO*/}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_107"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Showing the past moves Since you are recording the tic-tac-toe games history, you can now display a list of past moves to the player React elements like button are regular JavaScript objects; you can pass them around in your application To render multiple items in React, you can use an array of React elements",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_108"
        },
        {
          "content": "You already have an array of history moves in state, so now you need to transform it to an array of React elements In JavaScript, to transform one array into another, you can use the array map method: [1, 2, 3] map((x) = x * 2) // [2, 4, 6] Youll use map to transform your history of moves into React elements representing buttons on the screen, and display a list of buttons to jump to past moves",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_109"
        },
        {
          "content": "Lets map over the history in the Game component: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9) fill(null)]); const currentSquares = history[history length - 1]; function handlePlay(nextSquares) { setHistory([ history, nextSquares]); setXIsNext( xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_110"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div );} You can see what your code should look like below",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_111"
        },
        {
          "content": "Note that you should see an error in the developer tools console that says: ConsoleWarning: Each child in an array or iterator should have a unique key prop Check the render method of `Game` Youll fix this error in the next section App jsApp",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_112"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_113"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_114"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_115"
        },
        {
          "content": "fill(null)]); const currentSquares = history[history length - 1]; function handlePlay(nextSquares) { setHistory([ history, nextSquares]); setXIsNext( xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_116"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_117"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more As you iterate through the history array inside the function you passed to map, the squares argument goes through each element of history, and the move argument goes through each array index: 0, 1, 2, (In most cases, youd need the actual array elements, but to render a list of moves you will only need indexes",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_118"
        },
        {
          "content": ") For each move in the tic-tac-toe games history, you create a list item li which contains a button button The button has an onClick handler which calls a function called jumpTo (that you havent implemented yet) For now, you should see a list of the moves that occurred in the game and an error in the developer tools console Lets discuss what the key error means Picking a key When you render a list, React stores some information about each rendered list item",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_119"
        },
        {
          "content": "When you update a list, React needs to determine what has changed You could have added, removed, re-arranged, or updated the lists items Imagine transitioning from liAlexa: 7 tasks left/liliBen: 5 tasks left/li to liBen: 9 tasks left/liliClaudia: 8 tasks left/liliAlexa: 5 tasks left/li In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Bens ordering and inserted Claudia between Alexa and Ben",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_120"
        },
        {
          "content": "However, React is a computer program and does not know what you intended, so you need to specify a key property for each list item to differentiate each list item from its siblings If your data was from a database, Alexa, Ben, and Claudias database IDs could be used as keys li key={user id} {user name}: {user taskCount} tasks left/li When a list is re-rendered, React takes each list items key and searches the previous lists items for a matching key",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_121"
        },
        {
          "content": "If the current list has a key that didnt exist before, React creates a component If the current list is missing a key that existed in the previous list, React destroys the previous component If two keys match, the corresponding component is moved Keys tell React about the identity of each component, which allows React to maintain state between re-renders If a components key changes, the component will be destroyed and re-created with a new state key is a special and reserved property in React",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_122"
        },
        {
          "content": "When an element is created, React extracts the key property and stores the key directly on the returned element Even though key may look like it is passed as props, React automatically uses key to decide which components to update Theres no way for a component to ask what key its parent specified Its strongly recommended that you assign proper keys whenever you build dynamic lists If you dont have an appropriate key, you may want to consider restructuring your data so that you do",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_123"
        },
        {
          "content": "If no key is specified, React will report an error and use the array index as a key by default Using the array index as a key is problematic when trying to re-order a lists items or inserting/removing list items Explicitly passing key={i} silences the error but has the same problems as array indices and is not recommended in most cases Keys do not need to be globally unique; they only need to be unique between components and their siblings",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_124"
        },
        {
          "content": "Implementing time travel In the tic-tac-toe games history, each past move has a unique ID associated with it: its the sequential number of the move Moves will never be re-ordered, deleted, or inserted in the middle, so its safe to use the move index as a key In the Game function, you can add the key as li key={move}, and if you reload the rendered game, Reacts key error should disappear: const moves = history map((squares, move) = { //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_125"
        },
        {
          "content": "return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li );}); App jsApp js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_126"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_127"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_128"
        },
        {
          "content": "fill(null)]); const currentSquares = history[history length - 1]; function handlePlay(nextSquares) { setHistory([ history, nextSquares]); setXIsNext( xIsNext); } function jumpTo(nextMove) { // TODO } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_129"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_130"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Before you can implement jumpTo, you need the Game component to keep track of which step the user is currently viewing To do this, define a new state variable called currentMove, defaulting to 0: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_131"
        },
        {
          "content": "fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[history length - 1]; // } Next, update the jumpTo function inside Game to update that currentMove Youll also set xIsNext to true if the number that youre changing currentMove to is even export default function Game() { // function jumpTo(nextMove) { setCurrentMove(nextMove); setXIsNext(nextMove  2 === 0); } //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_132"
        },
        {
          "content": "} You will now make two changes to the Games handlePlay function which is called when you click on a square If you go back in time and then make a new move from that point, you only want to keep the history up to that point Instead of adding nextSquares after all items ( spread syntax) in history, youll add it after all items in history slice(0, currentMove + 1) so that youre only keeping that portion of the old history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_133"
        },
        {
          "content": "Each time a move is made, you need to update currentMove to point to the latest history entry function handlePlay(nextSquares) { const nextHistory = [ history slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory length - 1); setXIsNext(",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_134"
        },
        {
          "content": "xIsNext);} Finally, you will modify the Game component to render the currently selected move, instead of always rendering the final move: export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9) fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[currentMove]; //",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_135"
        },
        {
          "content": "} If you click on any step in the games history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred App jsApp js ResetForkimport { useState } from 'react'; function Square({value, onSquareClick}) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_136"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_137"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [xIsNext, setXIsNext] = useState(true); const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_138"
        },
        {
          "content": "fill(null)]); const [currentMove, setCurrentMove] = useState(0); const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [ history slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory length - 1); setXIsNext( xIsNext); } function jumpTo(nextMove) { setCurrentMove(nextMove); setXIsNext(nextMove  2 === 0); } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_139"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_140"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more Final cleanup If you look at the code very closely, you may notice that xIsNext === true when currentMove is even and xIsNext === false when currentMove is odd In other words, if you know the value of currentMove, then you can always figure out what xIsNext should be Theres no reason for you to store both of these in state",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_141"
        },
        {
          "content": "In fact, always try to avoid redundant state Simplifying what you store in state reduces bugs and makes your code easier to understand Change Game so that it doesnt store xIsNext as a separate state variable and instead figures it out based on the currentMove: export default function Game() { const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_142"
        },
        {
          "content": "fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [ history slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } // } You no longer need the xIsNext state declaration or the calls to setXIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_143"
        },
        {
          "content": "Now, theres no chance for xIsNext to get out of sync with currentMove, even if you make a mistake while coding the components Wrapping up Congratulations Youve created a tic-tac-toe game that: Lets you play tic-tac-toe, Indicates when a player has won the game, Stores a games history as a game progresses, Allows players to review a games history and see previous versions of a games board Nice work We hope you now feel like you have a decent grasp of how React works",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_144"
        },
        {
          "content": "Check out the final result here: App jsApp js ResetForkimport { useState } from 'react'; function Square({ value, onSquareClick }) { return ( button className=\"square\" onClick={onSquareClick} {value} /button ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { if (calculateWinner(squares)  squares[i]) { return; } const nextSquares = squares",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_145"
        },
        {
          "content": "slice(); if (xIsNext) { nextSquares[i] = 'X'; } else { nextSquares[i] = 'O'; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = 'Winner: ' + winner; } else { status = 'Next player: ' + (xIsNext",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_146"
        },
        {
          "content": "'X' : 'O'); } return (  div className=\"status\"{status}/div div className=\"board-row\" Square value={squares[0]} onSquareClick={() = handleClick(0)} / Square value={squares[1]} onSquareClick={() = handleClick(1)} / Square value={squares[2]} onSquareClick={() = handleClick(2)} / /div div className=\"board-row\" Square value={squares[3]} onSquareClick={() = handleClick(3)} / Square value={squares[4]} onSquareClick={() = handleClick(4)} / Square value={squares[5]} onSquareClick={() = handleClick(5)} / /div div className=\"board-row\" Square value={squares[6]} onSquareClick={() = handleClick(6)} / Square value={squares[7]} onSquareClick={() = handleClick(7)} / Square value={squares[8]} onSquareClick={() = handleClick(8)} / /div / ); } export default function Game() { const [history, setHistory] = useState([Array(9)",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_147"
        },
        {
          "content": "fill(null)]); const [currentMove, setCurrentMove] = useState(0); const xIsNext = currentMove  2 === 0; const currentSquares = history[currentMove]; function handlePlay(nextSquares) { const nextHistory = [ history slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory length - 1); } function jumpTo(nextMove) { setCurrentMove(nextMove); } const moves = history",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_148"
        },
        {
          "content": "map((squares, move) = { let description; if (move  0) { description = 'Go to move ' + move; } else { description = 'Go to game start'; } return ( li key={move} button onClick={() = jumpTo(move)}{description}/button /li ); }); return ( div className=\"game\" div className=\"game-board\" Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} / /div div className=\"game-info\" ol{moves}/ol /div /div ); } function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i  lines",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_149"
        },
        {
          "content": "length; i++) { const [a, b, c] = lines[i]; if (squares[a]  squares[a] === squares[b]  squares[a] === squares[c]) { return squares[a]; } } return null; } Show more If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty: For the current move only, show You are at move  instead of a button Rewrite Board to use two loops to make the squares instead of hardcoding them",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_150"
        },
        {
          "content": "Add a toggle button that lets you sort the moves in either ascending or descending order When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw) Display the location for each move in the format (row, col) in the move history list Throughout this tutorial, youve touched on React concepts including elements, components, props, and state",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_151"
        },
        {
          "content": "Now that youve seen how these concepts work when building a game, check out Thinking in React to see how the same React concepts work when building an apps UI PreviousQuick StartNextThinking in ReactCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_152"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/tutorial-tic-tac-toe",
          "library": "react",
          "chunk_id": "react_153"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/thinking-in-react",
      "title": "Thinking in React \u2013 React",
      "content": "Learn ReactQuick StartThinking in ReactReact can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called components. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, well guide you through the thought process of building a searchable product data table with React. Start with the mockup Imagine that you already have a JSON API and a mockup from a designer. The JSON API returns some data that looks like this: [ { category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\" }, { category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\" }, { category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\" }, { category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\" }, { category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\" }, { category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\" }] The mockup looks like this: To implement a UI in React, you will usually follow the same five steps. Step 1: Break the UI into a component hierarchy Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them! Depending on your background, you can think about splitting up a design into components in different ways: Programminguse the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents. CSSconsider what you would make class selectors for. (However, components are a bit less granular.) Designconsider how you would organize the designs layers. If your JSON is well-structured, youll often find that it naturally maps to the component structure of your UI. Thats because UI and data models often have the same information architecturethat is, the same shape. Separate your UI into components, where each component matches one piece of your data model. There are five components on this screen: FilterableProductTable (grey) contains the entire app. SearchBar (blue) receives the user input. ProductTable (lavender) displays and filters the list according to the user input. ProductCategoryRow (green) displays a heading for each category. ProductRow (yellow) displays a row for each product. If you look at ProductTable (lavender), youll see that the table header (containing the Name and Price labels) isnt its own component. This is a matter of preference, and you could go either way. For this example, it is a part of ProductTable because it appears inside the ProductTables list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its own ProductTableHeader component. Now that youve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy: FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow Step 2: Build a static version in React Now that you have your component hierarchy, its time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity yet! Its often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing. To build a static version of your app that renders your data model, youll want to build components that reuse other components and pass data using props. Props are a way of passing data from parent to child. (If youre familiar with the concept of state, dont use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you dont need it.) You can either build top down by starting with building the components higher up in the hierarchy (like FilterableProductTable) or bottom up by working from components lower down (like ProductRow). In simpler examples, its usually easier to go top-down, and on larger projects, its easier to go bottom-up. App.jsApp.js ResetForkfunction ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product.stocked ? product.name : span style={{ color: 'red' }} {product.name} /span; return ( tr td{name}/td td{product.price}/td /tr ); } function ProductTable({ products }) { const rows = []; let lastCategory = null; products.forEach((product) = { if (product.category !== lastCategory) { rows.push( ProductCategoryRow category={product.category} key={product.category} / ); } rows.push( ProductRow product={product} key={product.name} / ); lastCategory = product.category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar() { return ( form input type=\"text\" placeholder=\"Search...\" / label input type=\"checkbox\" / {' '} Only show products in stock /label /form ); } function FilterableProductTable({ products }) { return ( div SearchBar / ProductTable products={products} / /div ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more (If this code looks intimidating, go through the Quick Start first!) After building your components, youll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree. PitfallAt this point, you should not be using any state values. Thats for the next step! Step 3: Find the minimal but complete representation of UI state To make the UI interactive, you need to let users change your underlying data model. You will use state for this. Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it DRY (Dont Repeat Yourself). Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if youre building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, dont store the number of items as another state valueinstead, read the length of your array. Now think of all of the pieces of data in this example application: The original list of products The search text the user has entered The value of the checkbox The filtered list of products Which of these are state? Identify the ones that are not: Does it remain unchanged over time? If so, it isnt state. Is it passed in from a parent via props? If so, it isnt state. Can you compute it based on existing state or props in your component? If so, it definitely isnt state! Whats left is probably state. Lets go through them one by one again: The original list of products is passed in as props, so its not state. The search text seems to be state since it changes over time and cant be computed from anything. The value of the checkbox seems to be state since it changes over time and cant be computed from anything. The filtered list of products isnt state because it can be computed by taking the original list of products and filtering it according to the search text and value of the checkbox. This means only the search text and the value of the checkbox are state! Nicely done! Deep DiveProps vs State Show DetailsThere are two types of model data in React: props and state. The two are very different: Props are like arguments you pass to a function. They let a parent component pass data to a child component and customize its appearance. For example, a Form can pass a color prop to a Button. State is like a components memory. It lets a component keep track of some information and change it in response to interactions. For example, a Button might keep track of isHovered state. Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props. Its okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick! Step 4: Identify where your state should live After identifying your apps minimal state data, you need to identify which component is responsible for changing this state, or owns the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if youre new to this concept, but you can figure it out by following these steps! For each piece of state in your application: Identify every component that renders something based on that state. Find their closest common parent componenta component above them all in the hierarchy. Decide where the state should live: Often, you can put the state directly into their common parent. You can also put the state into some component above their common parent. If you cant find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component. In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place. Now lets run through our strategy for them: Identify components that use state: ProductTable needs to filter the product list based on that state (search text and checkbox value). SearchBar needs to display that state (search text and checkbox value). Find their common parent: The first parent component both components share is FilterableProductTable. Decide where the state lives: Well keep the filter text and checked state values in FilterableProductTable. So the state values will live in FilterableProductTable. Add state to the component with the useState() Hook. Hooks are special functions that let you hook into React. Add two state variables at the top of FilterableProductTable and specify their initial state: function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); Then, pass filterText and inStockOnly to ProductTable and SearchBar as props: div SearchBar filterText={filterText} inStockOnly={inStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} //div You can start seeing how your application will behave. Edit the filterText initial value from useState('') to useState('fruit') in the sandbox code below. Youll see both the search input text and the table update: App.jsApp.js ResetForkimport { useState } from 'react'; function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} / /div ); } function ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product.stocked ? product.name : span style={{ color: 'red' }} {product.name} /span; return ( tr td{name}/td td{product.price}/td /tr ); } function ProductTable({ products, filterText, inStockOnly }) { const rows = []; let lastCategory = null; products.forEach((product) = { if ( product.name.toLowerCase().indexOf( filterText.toLowerCase() ) === -1 ) { return; } if (inStockOnly  !product.stocked) { return; } if (product.category !== lastCategory) { rows.push( ProductCategoryRow category={product.category} key={product.category} / ); } rows.push( ProductRow product={product} key={product.name} / ); lastCategory = product.category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar({ filterText, inStockOnly }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search...\"/ label input type=\"checkbox\" checked={inStockOnly} / {' '} Only show products in stock /label /form ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more Notice that editing the form doesnt work yet. There is a console error in the sandbox above explaining why: ConsoleYou provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. In the sandbox above, ProductTable and SearchBar read the filterText and inStockOnly props to render the table, the input, and the checkbox. For example, here is how SearchBar populates the input value: function SearchBar({ filterText, inStockOnly }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search...\"/ However, you havent added any code to respond to the user actions like typing yet. This will be your final step. Step 5: Add inverse data flow Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in FilterableProductTable. React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, youll see that React ignores your input. This is intentional. By writing input value={filterText} /, youve set the value prop of the input to always be equal to the filterText state passed in from FilterableProductTable. Since filterText state is never set, the input never changes. You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned by FilterableProductTable, so only it can call setFilterText and setInStockOnly. To let SearchBar update the FilterableProductTables state, you need to pass these functions down to SearchBar: function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} onFilterTextChange={setFilterText} onInStockOnlyChange={setInStockOnly} / Inside the SearchBar, you will add the onChange event handlers and set the parent state from them: function SearchBar({ filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange}) { return ( form input type=\"text\" value={filterText} placeholder=\"Search...\" onChange={(e) = onFilterTextChange(e.target.value)} / label input type=\"checkbox\" checked={inStockOnly} onChange={(e) = onInStockOnlyChange(e.target.checked)} Now the application fully works! App.jsApp.js ResetForkimport { useState } from 'react'; function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} onFilterTextChange={setFilterText} onInStockOnlyChange={setInStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} / /div ); } function ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product.stocked ? product.name : span style={{ color: 'red' }} {product.name} /span; return ( tr td{name}/td td{product.price}/td /tr ); } function ProductTable({ products, filterText, inStockOnly }) { const rows = []; let lastCategory = null; products.forEach((product) = { if ( product.name.toLowerCase().indexOf( filterText.toLowerCase() ) === -1 ) { return; } if (inStockOnly  !product.stocked) { return; } if (product.category !== lastCategory) { rows.push( ProductCategoryRow category={product.category} key={product.category} / ); } rows.push( ProductRow product={product} key={product.name} / ); lastCategory = product.category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar({ filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search...\" onChange={(e) = onFilterTextChange(e.target.value)} / label input type=\"checkbox\" checked={inStockOnly} onChange={(e) = onInStockOnlyChange(e.target.checked)} / {' '} Only show products in stock /label /form ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more You can learn all about handling events and updating state in the Adding Interactivity section. Where to go from here This was a very brief introduction to how to think about building components and applications with React. You can start a React project right now or dive deeper on all the syntax used in this tutorial.PreviousTutorial: Tic-Tac-ToeNextInstallationCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "[  { category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\" },  { category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\" },  { category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\" },  { category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\" },  { category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\" },  { category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\" }]",
        "[  { category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\" },  { category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\" },  { category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\" },  { category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\" },  { category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\" },  { category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\" }]",
        "FilterableProductTable",
        "ProductTable",
        "ProductCategoryRow",
        "ProductTable",
        "ProductTable",
        "ProductTable",
        "ProductTableHeader",
        "FilterableProductTable",
        "ProductTable",
        "ProductCategoryRow",
        "FilterableProductTable",
        "function ProductCategoryRow({ category }) {\n  return (\n    <tr>\n      <th colSpan=\"2\">\n        {category}\n      </th>\n    </tr>\n  );\n}\n\nfunction ProductRow({ product }) {\n  const name = product.stocked ? product.name :\n    <span style={{ color: 'red' }}>\n      {product.name}\n    </span>;\n\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{product.price}</td>\n    </tr>\n  );\n}\n\nfunction ProductTable({ products }) {\n  const rows = [];\n  let lastCategory = null;\n\n  products.forEach((product) => {\n    if (product.category !== lastCategory) {\n      rows.push(\n        <ProductCategoryRow\n          category={product.category}\n          key={product.category} />\n      );\n    }\n    rows.push(\n      <ProductRow\n        product={product}\n        key={product.name} />\n    );\n    lastCategory = product.category;\n  });\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Price</th>\n        </tr>\n      </thead>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\nfunction SearchBar() {\n  return (\n    <form>\n      <input type=\"text\" placeholder=\"Search...\" />\n      <label>\n        <input type=\"checkbox\" />\n        {' '}\n        Only show products in stock\n      </label>\n    </form>\n  );\n}\n\nfunction FilterableProductTable({ products }) {\n  return (\n    <div>\n      <SearchBar />\n      <ProductTable products={products} />\n    </div>\n  );\n}\n\nconst PRODUCTS = [\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\"},\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\"},\n  {category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\"},\n  {category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\"},\n  {category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\"},\n  {category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\"}\n];\n\nexport default function App() {\n  return <FilterableProductTable products={PRODUCTS} />;\n}",
        "FilterableProductTable",
        "ProductTable",
        "FilterableProductTable",
        "FilterableProductTable",
        "FilterableProductTable",
        "FilterableProductTable",
        "function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);",
        "function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);",
        "inStockOnly",
        "ProductTable",
        "<div>  <SearchBar     filterText={filterText}     inStockOnly={inStockOnly} />  <ProductTable     products={products}    filterText={filterText}    inStockOnly={inStockOnly} /></div>",
        "<div>  <SearchBar     filterText={filterText}     inStockOnly={inStockOnly} />  <ProductTable     products={products}    filterText={filterText}    inStockOnly={inStockOnly} /></div>",
        "useState('')",
        "useState('fruit')",
        "import { useState } from 'react';\n\nfunction FilterableProductTable({ products }) {\n  const [filterText, setFilterText] = useState('');\n  const [inStockOnly, setInStockOnly] = useState(false);\n\n  return (\n    <div>\n      <SearchBar \n        filterText={filterText} \n        inStockOnly={inStockOnly} />\n      <ProductTable \n        products={products}\n        filterText={filterText}\n        inStockOnly={inStockOnly} />\n    </div>\n  );\n}\n\nfunction ProductCategoryRow({ category }) {\n  return (\n    <tr>\n      <th colSpan=\"2\">\n        {category}\n      </th>\n    </tr>\n  );\n}\n\nfunction ProductRow({ product }) {\n  const name = product.stocked ? product.name :\n    <span style={{ color: 'red' }}>\n      {product.name}\n    </span>;\n\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{product.price}</td>\n    </tr>\n  );\n}\n\nfunction ProductTable({ products, filterText, inStockOnly }) {\n  const rows = [];\n  let lastCategory = null;\n\n  products.forEach((product) => {\n    if (\n      product.name.toLowerCase().indexOf(\n        filterText.toLowerCase()\n      ) === -1\n    ) {\n      return;\n    }\n    if (inStockOnly && !product.stocked) {\n      return;\n    }\n    if (product.category !== lastCategory) {\n      rows.push(\n        <ProductCategoryRow\n          category={product.category}\n          key={product.category} />\n      );\n    }\n    rows.push(\n      <ProductRow\n        product={product}\n        key={product.name} />\n    );\n    lastCategory = product.category;\n  });\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Price</th>\n        </tr>\n      </thead>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\nfunction SearchBar({ filterText, inStockOnly }) {\n  return (\n    <form>\n      <input \n        type=\"text\" \n        value={filterText} \n        placeholder=\"Search...\"/>\n      <label>\n        <input \n          type=\"checkbox\" \n          checked={inStockOnly} />\n        {' '}\n        Only show products in stock\n      </label>\n    </form>\n  );\n}\n\nconst PRODUCTS = [\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\"},\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\"},\n  {category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\"},\n  {category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\"},\n  {category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\"},\n  {category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\"}\n];\n\nexport default function App() {\n  return <FilterableProductTable products={PRODUCTS} />;\n}",
        "ProductTable",
        "inStockOnly",
        "function SearchBar({ filterText, inStockOnly }) {  return (    <form>      <input         type=\"text\"         value={filterText}         placeholder=\"Search...\"/>",
        "function SearchBar({ filterText, inStockOnly }) {  return (    <form>      <input         type=\"text\"         value={filterText}         placeholder=\"Search...\"/>",
        "FilterableProductTable",
        "<input value={filterText} />",
        "FilterableProductTable",
        "FilterableProductTable",
        "setFilterText",
        "setInStockOnly",
        "FilterableProductTable",
        "function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);  return (    <div>      <SearchBar         filterText={filterText}         inStockOnly={inStockOnly}        onFilterTextChange={setFilterText}        onInStockOnlyChange={setInStockOnly} />",
        "function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);  return (    <div>      <SearchBar         filterText={filterText}         inStockOnly={inStockOnly}        onFilterTextChange={setFilterText}        onInStockOnlyChange={setInStockOnly} />",
        "function SearchBar({  filterText,  inStockOnly,  onFilterTextChange,  onInStockOnlyChange}) {  return (    <form>      <input        type=\"text\"        value={filterText}        placeholder=\"Search...\"        onChange={(e) => onFilterTextChange(e.target.value)}      />      <label>        <input          type=\"checkbox\"          checked={inStockOnly}          onChange={(e) => onInStockOnlyChange(e.target.checked)}",
        "function SearchBar({  filterText,  inStockOnly,  onFilterTextChange,  onInStockOnlyChange}) {  return (    <form>      <input        type=\"text\"        value={filterText}        placeholder=\"Search...\"        onChange={(e) => onFilterTextChange(e.target.value)}      />      <label>        <input          type=\"checkbox\"          checked={inStockOnly}          onChange={(e) => onInStockOnlyChange(e.target.checked)}",
        "import { useState } from 'react';\n\nfunction FilterableProductTable({ products }) {\n  const [filterText, setFilterText] = useState('');\n  const [inStockOnly, setInStockOnly] = useState(false);\n\n  return (\n    <div>\n      <SearchBar \n        filterText={filterText} \n        inStockOnly={inStockOnly} \n        onFilterTextChange={setFilterText} \n        onInStockOnlyChange={setInStockOnly} />\n      <ProductTable \n        products={products} \n        filterText={filterText}\n        inStockOnly={inStockOnly} />\n    </div>\n  );\n}\n\nfunction ProductCategoryRow({ category }) {\n  return (\n    <tr>\n      <th colSpan=\"2\">\n        {category}\n      </th>\n    </tr>\n  );\n}\n\nfunction ProductRow({ product }) {\n  const name = product.stocked ? product.name :\n    <span style={{ color: 'red' }}>\n      {product.name}\n    </span>;\n\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{product.price}</td>\n    </tr>\n  );\n}\n\nfunction ProductTable({ products, filterText, inStockOnly }) {\n  const rows = [];\n  let lastCategory = null;\n\n  products.forEach((product) => {\n    if (\n      product.name.toLowerCase().indexOf(\n        filterText.toLowerCase()\n      ) === -1\n    ) {\n      return;\n    }\n    if (inStockOnly && !product.stocked) {\n      return;\n    }\n    if (product.category !== lastCategory) {\n      rows.push(\n        <ProductCategoryRow\n          category={product.category}\n          key={product.category} />\n      );\n    }\n    rows.push(\n      <ProductRow\n        product={product}\n        key={product.name} />\n    );\n    lastCategory = product.category;\n  });\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Price</th>\n        </tr>\n      </thead>\n      <tbody>{rows}</tbody>\n    </table>\n  );\n}\n\nfunction SearchBar({\n  filterText,\n  inStockOnly,\n  onFilterTextChange,\n  onInStockOnlyChange\n}) {\n  return (\n    <form>\n      <input \n        type=\"text\" \n        value={filterText} placeholder=\"Search...\" \n        onChange={(e) => onFilterTextChange(e.target.value)} />\n      <label>\n        <input \n          type=\"checkbox\" \n          checked={inStockOnly} \n          onChange={(e) => onInStockOnlyChange(e.target.checked)} />\n        {' '}\n        Only show products in stock\n      </label>\n    </form>\n  );\n}\n\nconst PRODUCTS = [\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\"},\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\"},\n  {category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\"},\n  {category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\"},\n  {category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\"},\n  {category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\"}\n];\n\nexport default function App() {\n  return <FilterableProductTable products={PRODUCTS} />;\n}"
      ],
      "chunks": [
        {
          "content": "Learn ReactQuick StartThinking in ReactReact can change how you think about the designs you look at and the apps you build When you build a user interface with React, you will first break it apart into pieces called components Then, you will describe the different visual states for each of your components Finally, you will connect your components together so that the data flows through them",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "In this tutorial, well guide you through the thought process of building a searchable product data table with React Start with the mockup Imagine that you already have a JSON API and a mockup from a designer",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "The JSON API returns some data that looks like this: [ { category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\" }, { category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\" }, { category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\" }, { category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\" }, { category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\" }, { category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\" }] The mockup looks like this: To implement a UI in React, you will usually follow the same five steps",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Step 1: Break the UI into a component hierarchy Start by drawing boxes around every component and subcomponent in the mockup and naming them If you work with a designer, they may have already named these components in their design tool Ask them Depending on your background, you can think about splitting up a design into components in different ways: Programminguse the same techniques for deciding if you should create a new function or object",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "One such technique is the single responsibility principle, that is, a component should ideally only do one thing If it ends up growing, it should be decomposed into smaller subcomponents CSSconsider what you would make class selectors for (However, components are a bit less granular ) Designconsider how you would organize the designs layers If your JSON is well-structured, youll often find that it naturally maps to the component structure of your UI",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Thats because UI and data models often have the same information architecturethat is, the same shape Separate your UI into components, where each component matches one piece of your data model There are five components on this screen: FilterableProductTable (grey) contains the entire app SearchBar (blue) receives the user input ProductTable (lavender) displays and filters the list according to the user input ProductCategoryRow (green) displays a heading for each category",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "ProductRow (yellow) displays a row for each product If you look at ProductTable (lavender), youll see that the table header (containing the Name and Price labels) isnt its own component This is a matter of preference, and you could go either way For this example, it is a part of ProductTable because it appears inside the ProductTables list However, if this header grows to be complex (e g , if you add sorting), you can move it into its own ProductTableHeader component",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "Now that youve identified the components in the mockup, arrange them into a hierarchy Components that appear within another component in the mockup should appear as a child in the hierarchy: FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow Step 2: Build a static version in React Now that you have your component hierarchy, its time to implement your app",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity yet Its often easier to build the static version first and add interactivity later Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "To build a static version of your app that renders your data model, youll want to build components that reuse other components and pass data using props Props are a way of passing data from parent to child (If youre familiar with the concept of state, dont use state at all to build this static version State is reserved only for interactivity, that is, data that changes over time Since this is a static version of the app, you dont need it",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": ") You can either build top down by starting with building the components higher up in the hierarchy (like FilterableProductTable) or bottom up by working from components lower down (like ProductRow) In simpler examples, its usually easier to go top-down, and on larger projects, its easier to go bottom-up App jsApp js ResetForkfunction ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product stocked product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "name : span style={{ color: 'red' }} {product name} /span; return ( tr td{name}/td td{product price}/td /tr ); } function ProductTable({ products }) { const rows = []; let lastCategory = null; products forEach((product) = { if (product category == lastCategory) { rows push( ProductCategoryRow category={product category} key={product category} / ); } rows push( ProductRow product={product} key={product name} / ); lastCategory = product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar() { return ( form input type=\"text\" placeholder=\"Search",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "\" / label input type=\"checkbox\" / {' '} Only show products in stock /label /form ); } function FilterableProductTable({ products }) { return ( div SearchBar / ProductTable products={products} / /div ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more (If this code looks intimidating, go through the Quick Start first",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": ") After building your components, youll have a library of reusable components that render your data model Because this is a static app, the components will only return JSX The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree PitfallAt this point, you should not be using any state values Thats for the next step",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "Step 3: Find the minimal but complete representation of UI state To make the UI interactive, you need to let users change your underlying data model You will use state for this Think of state as the minimal set of changing data that your app needs to remember The most important principle for structuring state is to keep it DRY (Dont Repeat Yourself) Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "For example, if youre building a shopping list, you can store the items as an array in state If you want to also display the number of items in the list, dont store the number of items as another state valueinstead, read the length of your array Now think of all of the pieces of data in this example application: The original list of products The search text the user has entered The value of the checkbox The filtered list of products Which of these are state",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "Identify the ones that are not: Does it remain unchanged over time If so, it isnt state Is it passed in from a parent via props If so, it isnt state Can you compute it based on existing state or props in your component If so, it definitely isnt state Whats left is probably state Lets go through them one by one again: The original list of products is passed in as props, so its not state The search text seems to be state since it changes over time and cant be computed from anything",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "The value of the checkbox seems to be state since it changes over time and cant be computed from anything The filtered list of products isnt state because it can be computed by taking the original list of products and filtering it according to the search text and value of the checkbox This means only the search text and the value of the checkbox are state Nicely done Deep DiveProps vs State Show DetailsThere are two types of model data in React: props and state",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "The two are very different: Props are like arguments you pass to a function They let a parent component pass data to a child component and customize its appearance For example, a Form can pass a color prop to a Button State is like a components memory It lets a component keep track of some information and change it in response to interactions For example, a Button might keep track of isHovered state Props and state are different, but they work together",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props Its okay if the difference still feels fuzzy on the first read It takes a bit of practice for it to really stick Step 4: Identify where your state should live After identifying your apps minimal state data, you need to identify which component is responsible for changing this state, or owns the state",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component It may not be immediately clear which component should own what state This can be challenging if youre new to this concept, but you can figure it out by following these steps For each piece of state in your application: Identify every component that renders something based on that state Find their closest common parent componenta component above them all in the hierarchy",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "Decide where the state should live: Often, you can put the state directly into their common parent You can also put the state into some component above their common parent If you cant find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "In this example, they always appear together, so it makes sense to put them into the same place Now lets run through our strategy for them: Identify components that use state: ProductTable needs to filter the product list based on that state (search text and checkbox value) SearchBar needs to display that state (search text and checkbox value) Find their common parent: The first parent component both components share is FilterableProductTable",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "Decide where the state lives: Well keep the filter text and checked state values in FilterableProductTable So the state values will live in FilterableProductTable Add state to the component with the useState() Hook Hooks are special functions that let you hook into React",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "Add two state variables at the top of FilterableProductTable and specify their initial state: function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); Then, pass filterText and inStockOnly to ProductTable and SearchBar as props: div SearchBar filterText={filterText} inStockOnly={inStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} //div You can start seeing how your application will behave",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "Edit the filterText initial value from useState('') to useState('fruit') in the sandbox code below Youll see both the search input text and the table update: App jsApp",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} / /div ); } function ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "stocked product name : span style={{ color: 'red' }} {product name} /span; return ( tr td{name}/td td{product price}/td /tr ); } function ProductTable({ products, filterText, inStockOnly }) { const rows = []; let lastCategory = null; products forEach((product) = { if ( product name toLowerCase() indexOf( filterText toLowerCase() ) === -1 ) { return; } if (inStockOnly product stocked) { return; } if (product category == lastCategory) { rows push( ProductCategoryRow category={product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "category} key={product category} / ); } rows push( ProductRow product={product} key={product name} / ); lastCategory = product category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar({ filterText, inStockOnly }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "\"/ label input type=\"checkbox\" checked={inStockOnly} / {' '} Only show products in stock /label /form ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more Notice that editing the form doesnt work yet",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_30"
        },
        {
          "content": "There is a console error in the sandbox above explaining why: ConsoleYou provided a `value` prop to a form field without an `onChange` handler This will render a read-only field In the sandbox above, ProductTable and SearchBar read the filterText and inStockOnly props to render the table, the input, and the checkbox For example, here is how SearchBar populates the input value: function SearchBar({ filterText, inStockOnly }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_31"
        },
        {
          "content": "\"/ However, you havent added any code to respond to the user actions like typing yet This will be your final step Step 5: Add inverse data flow Currently your app renders correctly with props and state flowing down the hierarchy But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in FilterableProductTable",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_32"
        },
        {
          "content": "React makes this data flow explicit, but it requires a little more typing than two-way data binding If you try to type or check the box in the example above, youll see that React ignores your input This is intentional By writing input value={filterText} /, youve set the value prop of the input to always be equal to the filterText state passed in from FilterableProductTable Since filterText state is never set, the input never changes",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_33"
        },
        {
          "content": "You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes The state is owned by FilterableProductTable, so only it can call setFilterText and setInStockOnly",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_34"
        },
        {
          "content": "To let SearchBar update the FilterableProductTables state, you need to pass these functions down to SearchBar: function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} onFilterTextChange={setFilterText} onInStockOnlyChange={setInStockOnly} / Inside the SearchBar, you will add the onChange event handlers and set the parent state from them: function SearchBar({ filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange}) { return ( form input type=\"text\" value={filterText} placeholder=\"Search",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_35"
        },
        {
          "content": "\" onChange={(e) = onFilterTextChange(e target value)} / label input type=\"checkbox\" checked={inStockOnly} onChange={(e) = onInStockOnlyChange(e target checked)} Now the application fully works App jsApp",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_36"
        },
        {
          "content": "js ResetForkimport { useState } from 'react'; function FilterableProductTable({ products }) { const [filterText, setFilterText] = useState(''); const [inStockOnly, setInStockOnly] = useState(false); return ( div SearchBar filterText={filterText} inStockOnly={inStockOnly} onFilterTextChange={setFilterText} onInStockOnlyChange={setInStockOnly} / ProductTable products={products} filterText={filterText} inStockOnly={inStockOnly} / /div ); } function ProductCategoryRow({ category }) { return ( tr th colSpan=\"2\" {category} /th /tr ); } function ProductRow({ product }) { const name = product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_37"
        },
        {
          "content": "stocked product name : span style={{ color: 'red' }} {product name} /span; return ( tr td{name}/td td{product price}/td /tr ); } function ProductTable({ products, filterText, inStockOnly }) { const rows = []; let lastCategory = null; products forEach((product) = { if ( product name toLowerCase() indexOf( filterText toLowerCase() ) === -1 ) { return; } if (inStockOnly product stocked) { return; } if (product category == lastCategory) { rows push( ProductCategoryRow category={product",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_38"
        },
        {
          "content": "category} key={product category} / ); } rows push( ProductRow product={product} key={product name} / ); lastCategory = product category; }); return ( table thead tr thName/th thPrice/th /tr /thead tbody{rows}/tbody /table ); } function SearchBar({ filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange }) { return ( form input type=\"text\" value={filterText} placeholder=\"Search \" onChange={(e) = onFilterTextChange(e target",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_39"
        },
        {
          "content": "value)} / label input type=\"checkbox\" checked={inStockOnly} onChange={(e) = onInStockOnlyChange(e target",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_40"
        },
        {
          "content": "checked)} / {' '} Only show products in stock /label /form ); } const PRODUCTS = [ {category: \"Fruits\", price: \"1\", stocked: true, name: \"Apple\"}, {category: \"Fruits\", price: \"1\", stocked: true, name: \"Dragonfruit\"}, {category: \"Fruits\", price: \"2\", stocked: false, name: \"Passionfruit\"}, {category: \"Vegetables\", price: \"2\", stocked: true, name: \"Spinach\"}, {category: \"Vegetables\", price: \"4\", stocked: false, name: \"Pumpkin\"}, {category: \"Vegetables\", price: \"1\", stocked: true, name: \"Peas\"} ]; export default function App() { return FilterableProductTable products={PRODUCTS} /; } Show more You can learn all about handling events and updating state in the Adding Interactivity section",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_41"
        },
        {
          "content": "Where to go from here This was a very brief introduction to how to think about building components and applications with React You can start a React project right now or dive deeper on all the syntax used in this tutorial PreviousTutorial: Tic-Tac-ToeNextInstallationCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_42"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/thinking-in-react",
          "library": "react",
          "chunk_id": "react_43"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/creating-a-react-app",
      "title": "Creating a React App \u2013 React",
      "content": "Learn ReactInstallationCreating a React AppIf you want to build a new app or website with React, we recommend starting with a framework. If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch. Full-stack frameworks These recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of Reacts architecture. NoteFull-stack frameworks do not require a server. All the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG). These apps can be deployed to a CDN or static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case.This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your frameworks documentation for configuring the rendering strategy. Next.js (App Router) Next.jss App Router is a React framework that takes full advantage of Reacts architecture to enable full-stack React apps. Terminal Copynpx create-next-applatest Next.js is maintained by Vercel. You can deploy a Next.js app to any hosting provider that supports Node.js or Docker containers, or to your own server. Next.js also supports static export which doesnt require a server. React Router (v7) React Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms. To create a new React Router framework project, run: Terminal Copynpx create-react-routerlatest React Router is maintained by Shopify. Expo (for native apps) Expo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs. It provides an SDK for React Native that makes the native parts easier to use. To create a new Expo project, run: Terminal Copynpx create-expo-applatest If youre new to Expo, check out the Expo tutorial. Expo is maintained by Expo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services. Other frameworks There are other up-and-coming frameworks that are working towards our full stack React vision: TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite. RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications. Deep DiveWhich features make up the React teams full-stack architecture vision? Show DetailsNext.jss App Router bundler fully implements the official React Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree.For example, you can write a server-only React component as an async function that reads from a database or from a file. Then you can pass data down from it to your interactive components:// This component runs *only* on the server (or during the build).async function Talks({ confId }) { // 1. You're on the server, so you can talk to your data layer. API endpoint not required. const talks = await db.Talks.findAll({ confId }); // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger. const videos = talks.map(talk = talk.video); // 3. Pass the data down to the components that will run in the browser. return SearchableVideoList videos={videos} /;}Next.jss App Router also integrates data fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:Suspense fallback={TalksLoading /} Talks confId={conf.id} //SuspenseServer Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks. Start From Scratch If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch. Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns. Its a lot like building your own framework, instead of using a framework that already exists. The frameworks we recommend have built-in solutions for these problems. If you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a build tool like Vite, Parcel, or RSbuild. If youre a framework author interested in being included on this page, please let us know.PreviousInstallationNextBuild a React App from ScratchCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "// This component runs *only* on the server (or during the build).async function Talks({ confId }) {  // 1. You're on the server, so you can talk to your data layer. API endpoint not required.  const talks = await db.Talks.findAll({ confId });  // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.  const videos = talks.map(talk => talk.video);  // 3. Pass the data down to the components that will run in the browser.  return <SearchableVideoList videos={videos} />;}",
        "// This component runs *only* on the server (or during the build).async function Talks({ confId }) {  // 1. You're on the server, so you can talk to your data layer. API endpoint not required.  const talks = await db.Talks.findAll({ confId });  // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.  const videos = talks.map(talk => talk.video);  // 3. Pass the data down to the components that will run in the browser.  return <SearchableVideoList videos={videos} />;}",
        "<Suspense fallback={<TalksLoading />}>  <Talks confId={conf.id} /></Suspense>",
        "<Suspense fallback={<TalksLoading />}>  <Talks confId={conf.id} /></Suspense>"
      ],
      "chunks": [
        {
          "content": "Learn ReactInstallationCreating a React AppIf you want to build a new app or website with React, we recommend starting with a framework If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch Full-stack frameworks These recommended frameworks support all the features you need to deploy and scale your app in production",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "They have integrated the latest React features and take advantage of Reacts architecture NoteFull-stack frameworks do not require a server All the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG) These apps can be deployed to a CDN or static hosting service without a server Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app See your frameworks documentation for configuring the rendering strategy Next js (App Router) Next jss App Router is a React framework that takes full advantage of Reacts architecture to enable full-stack React apps Terminal Copynpx create-next-applatest Next js is maintained by Vercel You can deploy a Next",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "js app to any hosting provider that supports Node js or Docker containers, or to your own server Next js also supports static export which doesnt require a server React Router (v7) React Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "To create a new React Router framework project, run: Terminal Copynpx create-react-routerlatest React Router is maintained by Shopify Expo (for native apps) Expo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs It provides an SDK for React Native that makes the native parts easier to use To create a new Expo project, run: Terminal Copynpx create-expo-applatest If youre new to Expo, check out the Expo tutorial",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Expo is maintained by Expo (the company) Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions Expo additionally provides opt-in paid cloud services Other frameworks There are other up-and-coming frameworks that are working towards our full stack React vision: TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications Deep DiveWhich features make up the React teams full-stack architecture vision Show DetailsNext jss App Router bundler fully implements the official React Server Components specification",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "This lets you mix build-time, server-only, and interactive components in a single React tree For example, you can write a server-only React component as an async function that reads from a database or from a file Then you can pass data down from it to your interactive components:// This component runs *only* on the server (or during the build) async function Talks({ confId }) { // 1 You're on the server, so you can talk to your data layer API endpoint not required const talks = await db Talks",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "findAll({ confId }); // 2 Add any amount of rendering logic It won't make your JavaScript bundle larger const videos = talks map(talk = talk video); // 3 Pass the data down to the components that will run in the browser return SearchableVideoList videos={videos} /;}Next jss App Router also integrates data fetching with Suspense",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:Suspense fallback={TalksLoading /} Talks confId={conf id} //SuspenseServer Components and Suspense are React features rather than Next js features However, adopting them at the framework level requires buy-in and non-trivial implementation work At the moment, the Next js App Router is the most complete implementation",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks Start From Scratch If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns Its a lot like building your own framework, instead of using a framework that already exists The frameworks we recommend have built-in solutions for these problems",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "If you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a build tool like Vite, Parcel, or RSbuild If youre a framework author interested in being included on this page, please let us know PreviousInstallationNextBuild a React App from ScratchCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/creating-a-react-app",
          "library": "react",
          "chunk_id": "react_13"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/build-a-react-app-from-scratch",
      "title": "Build a React app from Scratch \u2013 React",
      "content": "Learn ReactInstallationBuild a React app from ScratchIf your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch. Deep DiveConsider using a framework Show DetailsStarting from scratch is an easy way to get started using React, but a major tradeoff to be aware of is that going this route is often the same as building your own adhoc framework. As your requirements evolve, you may need to solve more framework-like problems that our recommended frameworks already have well developed and supported solutions for.For example, if in the future your app needs support for server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC), you will have to implement those on your own. Similarly, future React features that require integrating at the framework level will have to be implemented on your own if you want to use them.Our recommended frameworks also help you build better performing apps. For example, reducing or eliminating waterfalls from network requests makes for a better user experience. This might not be a high priority when you are building a toy project, but if your app gains users you may want to improve its performance.Going this route also makes it more difficult to get support, since the way you develop routing, data-fetching, and other features will be unique to your situation. You should only choose this option if you are comfortable tackling these problems on your own, or if youre confident that you will never need these features.For a list of recommended frameworks, check out Creating a React App. Step 1: Install a build tool The first step is to install a build tool like vite, parcel, or rsbuild. These build tools provide features to package and run source code, provide a development server for local development and a build command to deploy your app to a production server. Vite Vite is a build tool that aims to provide a faster and leaner development experience for modern web projects. Terminal Copynpm create vitelatest my-app -- --template react Vite is opinionated and comes with sensible defaults out of the box. Vite has a rich ecosystem of plugins to support fast refresh, JSX, Babel/SWC, and other common features. See Vites React plugin or React SWC plugin and React SSR example project to get started. Vite is already being used as a build tool in one of our recommended frameworks: React Router. Parcel Parcel combines a great out-of-the-box development experience with a scalable architecture that can take your project from just getting started to massive production applications. Terminal Copynpm install --save-dev parcel Parcel supports fast refresh, JSX, TypeScript, Flow, and styling out of the box. See Parcels React recipe to get started. Rsbuild Rsbuild is an Rspack-powered build tool that provides a seamless development experience for React applications. It comes with carefully tuned defaults and performance optimizations ready to use. Terminal Copynpx create-rsbuild --template react Rsbuild includes built-in support for React features like fast refresh, JSX, TypeScript, and styling. See Rsbuilds React guide to get started. NoteMetro for React Native If youre starting from scratch with React Native youll need to use Metro, the JavaScript bundler for React Native. Metro supports bundling for platforms like iOS and Android, but lacks many features when compared to the tools here. We recommend starting with Vite, Parcel, or Rsbuild unless your project requires React Native support. Step 2: Build Common Application Patterns The build tools listed above start off with a client-only, single-page app (SPA), but dont include any further solutions for common functionality like routing, data fetching, or styling. The React ecosystem includes many tools for these problems. Weve listed a few that are widely used as a starting point, but feel free to choose other tools if those work better for you. Routing Routing determines what content or pages to display when a user visits a particular URL. You need to set up a router to map URLs to different parts of your app. Youll also need to handle nested routes, route parameters, and query parameters. Routers can be configured within your code, or defined based on your component folder and file structures. Routers are a core part of modern applications, and are usually integrated with data fetching (including prefetching data for a whole page for faster loading), code splitting (to minimize client bundle sizes), and page rendering approaches (to decide how each page gets generated). We suggest using: React Router Tanstack Router Data Fetching Fetching data from a server or other data source is a key part of most applications. Doing this properly requires handling loading states, error states, and caching the fetched data, which can be complex. Purpose-built data fetching libraries do the hard work of fetching and caching the data for you, letting you focus on what data your app needs and how to display it. These libraries are typically used directly in your components, but can also be integrated into routing loaders for faster pre-fetching and better performance, and in server rendering as well. Note that fetching data directly in components can lead to slower loading times due to network request waterfalls, so we recommend prefetching data in router loaders or on the server as much as possible! This allows a pages data to be fetched all at once as the page is being displayed. If youre fetching data from most backends or REST-style APIs, we suggest using: React Query SWR RTK Query If youre fetching data from a GraphQL API, we suggest using: Apollo Relay Code-splitting Code-splitting is the process of breaking your app into smaller bundles that can be loaded on demand. An apps code size increases with every new feature and additional dependency. Apps can become slow to load because all of the code for the entire app needs to be sent before it can be used. Caching, reducing features/dependencies, and moving some code to run on the server can help mitigate slow loading but are incomplete solutions that can sacrifice functionality if overused. Similarly, if you rely on the apps using your framework to split the code, you might encounter situations where loading becomes slower than if no code splitting were happening at all. For example, lazily loading a chart delays sending the code needed to render the chart, splitting the chart code from the rest of the app. Parcel supports code splitting with React.lazy. However, if the chart loads its data after it has been initially rendered you are now waiting twice. This is a waterfall: rather than fetching the data for the chart and sending the code to render it simultaneously, you must wait for each step to complete one after the other. Splitting code by route, when integrated with bundling and data fetching, can reduce the initial load time of your app and the time it takes for the largest visible content of the app to render (Largest Contentful Paint). For code-splitting instructions, see your build tool docs: Vite build optimizations Parcel code splitting Rsbuild code splitting Improving Application Performance Since the build tool you select only support single page apps (SPAs) youll need to implement other rendering patterns like server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC). Even if you dont need these features at first, in the future there may be some routes that would benefit SSR, SSG or RSC. Single-page apps (SPA) load a single HTML page and dynamically updates the page as the user interacts with the app. SPAs are easier to get started with, but they can have slower initial load times. SPAs are the default architecture for most build tools. Streaming Server-side rendering (SSR) renders a page on the server and sends the fully rendered page to the client. SSR can improve performance, but it can be more complex to set up and maintain than a single-page app. With the addition of streaming, SSR can be very complex to set up and maintain. See Vites SSR guide. Static site generation (SSG) generates static HTML files for your app at build time. SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering. See Vites SSG guide. React Server Components (RSC) lets you mix build-time, server-only, and interactive components in a single React tree. RSC can improve performance, but it currently requires deep expertise to set up and maintain. See Parcels RSC examples. Your rendering strategies need to integrate with your router so apps built with your framework can choose the rendering strategy on a per-route level. This will enable different rendering strategies without having to rewrite your whole app. For example, the landing page for your app might benefit from being statically generated (SSG), while a page with a content feed might perform best with server-side rendering. Using the right rendering strategy for the right routes can decrease the time it takes for the first byte of content to be loaded (Time to First Byte), the first piece of content to render (First Contentful Paint), and the largest visible content of the app to render (Largest Contentful Paint). And more These are just a few examples of the features a new app will need to consider when building from scratch. Many limitations youll hit can be difficult to solve as each problem is interconnected with the others and can require deep expertise in problem areas you may not be familiar with. If you dont want to solve these problems on your own, you can get started with a framework that provides these features out of the box.PreviousCreating a React AppNextAdd React to an Existing ProjectCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [],
      "chunks": [
        {
          "content": "Learn ReactInstallationBuild a React app from ScratchIf your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch Deep DiveConsider using a framework Show DetailsStarting from scratch is an easy way to get started using React, but a major tradeoff to be aware of is that going this route is often the same as building your own adhoc framework",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "As your requirements evolve, you may need to solve more framework-like problems that our recommended frameworks already have well developed and supported solutions for For example, if in the future your app needs support for server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC), you will have to implement those on your own",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Similarly, future React features that require integrating at the framework level will have to be implemented on your own if you want to use them Our recommended frameworks also help you build better performing apps For example, reducing or eliminating waterfalls from network requests makes for a better user experience This might not be a high priority when you are building a toy project, but if your app gains users you may want to improve its performance",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Going this route also makes it more difficult to get support, since the way you develop routing, data-fetching, and other features will be unique to your situation You should only choose this option if you are comfortable tackling these problems on your own, or if youre confident that you will never need these features For a list of recommended frameworks, check out Creating a React App Step 1: Install a build tool The first step is to install a build tool like vite, parcel, or rsbuild",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "These build tools provide features to package and run source code, provide a development server for local development and a build command to deploy your app to a production server Vite Vite is a build tool that aims to provide a faster and leaner development experience for modern web projects Terminal Copynpm create vitelatest my-app -- --template react Vite is opinionated and comes with sensible defaults out of the box",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Vite has a rich ecosystem of plugins to support fast refresh, JSX, Babel/SWC, and other common features See Vites React plugin or React SWC plugin and React SSR example project to get started Vite is already being used as a build tool in one of our recommended frameworks: React Router Parcel Parcel combines a great out-of-the-box development experience with a scalable architecture that can take your project from just getting started to massive production applications",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "Terminal Copynpm install --save-dev parcel Parcel supports fast refresh, JSX, TypeScript, Flow, and styling out of the box See Parcels React recipe to get started Rsbuild Rsbuild is an Rspack-powered build tool that provides a seamless development experience for React applications It comes with carefully tuned defaults and performance optimizations ready to use",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "Terminal Copynpx create-rsbuild --template react Rsbuild includes built-in support for React features like fast refresh, JSX, TypeScript, and styling See Rsbuilds React guide to get started NoteMetro for React Native If youre starting from scratch with React Native youll need to use Metro, the JavaScript bundler for React Native Metro supports bundling for platforms like iOS and Android, but lacks many features when compared to the tools here",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "We recommend starting with Vite, Parcel, or Rsbuild unless your project requires React Native support Step 2: Build Common Application Patterns The build tools listed above start off with a client-only, single-page app (SPA), but dont include any further solutions for common functionality like routing, data fetching, or styling The React ecosystem includes many tools for these problems",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "Weve listed a few that are widely used as a starting point, but feel free to choose other tools if those work better for you Routing Routing determines what content or pages to display when a user visits a particular URL You need to set up a router to map URLs to different parts of your app Youll also need to handle nested routes, route parameters, and query parameters Routers can be configured within your code, or defined based on your component folder and file structures",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "Routers are a core part of modern applications, and are usually integrated with data fetching (including prefetching data for a whole page for faster loading), code splitting (to minimize client bundle sizes), and page rendering approaches (to decide how each page gets generated) We suggest using: React Router Tanstack Router Data Fetching Fetching data from a server or other data source is a key part of most applications",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "Doing this properly requires handling loading states, error states, and caching the fetched data, which can be complex Purpose-built data fetching libraries do the hard work of fetching and caching the data for you, letting you focus on what data your app needs and how to display it These libraries are typically used directly in your components, but can also be integrated into routing loaders for faster pre-fetching and better performance, and in server rendering as well",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "Note that fetching data directly in components can lead to slower loading times due to network request waterfalls, so we recommend prefetching data in router loaders or on the server as much as possible This allows a pages data to be fetched all at once as the page is being displayed",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "If youre fetching data from most backends or REST-style APIs, we suggest using: React Query SWR RTK Query If youre fetching data from a GraphQL API, we suggest using: Apollo Relay Code-splitting Code-splitting is the process of breaking your app into smaller bundles that can be loaded on demand An apps code size increases with every new feature and additional dependency Apps can become slow to load because all of the code for the entire app needs to be sent before it can be used",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Caching, reducing features/dependencies, and moving some code to run on the server can help mitigate slow loading but are incomplete solutions that can sacrifice functionality if overused Similarly, if you rely on the apps using your framework to split the code, you might encounter situations where loading becomes slower than if no code splitting were happening at all",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "For example, lazily loading a chart delays sending the code needed to render the chart, splitting the chart code from the rest of the app Parcel supports code splitting with React lazy However, if the chart loads its data after it has been initially rendered you are now waiting twice This is a waterfall: rather than fetching the data for the chart and sending the code to render it simultaneously, you must wait for each step to complete one after the other",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "Splitting code by route, when integrated with bundling and data fetching, can reduce the initial load time of your app and the time it takes for the largest visible content of the app to render (Largest Contentful Paint)",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "For code-splitting instructions, see your build tool docs: Vite build optimizations Parcel code splitting Rsbuild code splitting Improving Application Performance Since the build tool you select only support single page apps (SPAs) youll need to implement other rendering patterns like server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC)",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "Even if you dont need these features at first, in the future there may be some routes that would benefit SSR, SSG or RSC Single-page apps (SPA) load a single HTML page and dynamically updates the page as the user interacts with the app SPAs are easier to get started with, but they can have slower initial load times SPAs are the default architecture for most build tools Streaming Server-side rendering (SSR) renders a page on the server and sends the fully rendered page to the client",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "SSR can improve performance, but it can be more complex to set up and maintain than a single-page app With the addition of streaming, SSR can be very complex to set up and maintain See Vites SSR guide Static site generation (SSG) generates static HTML files for your app at build time SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering See Vites SSG guide",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "React Server Components (RSC) lets you mix build-time, server-only, and interactive components in a single React tree RSC can improve performance, but it currently requires deep expertise to set up and maintain See Parcels RSC examples Your rendering strategies need to integrate with your router so apps built with your framework can choose the rendering strategy on a per-route level This will enable different rendering strategies without having to rewrite your whole app",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "For example, the landing page for your app might benefit from being statically generated (SSG), while a page with a content feed might perform best with server-side rendering Using the right rendering strategy for the right routes can decrease the time it takes for the first byte of content to be loaded (Time to First Byte), the first piece of content to render (First Contentful Paint), and the largest visible content of the app to render (Largest Contentful Paint)",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "And more These are just a few examples of the features a new app will need to consider when building from scratch Many limitations youll hit can be difficult to solve as each problem is interconnected with the others and can require deep expertise in problem areas you may not be familiar with If you dont want to solve these problems on your own, you can get started with a framework that provides these features out of the box",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "PreviousCreating a React AppNextAdd React to an Existing ProjectCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/build-a-react-app-from-scratch",
          "library": "react",
          "chunk_id": "react_23"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/learn/setup",
      "title": "Setup \u2013 React",
      "content": "Learn ReactSetupReact integrates with tools like editors, TypeScript, browser extensions, and compilers. This section will help you get your environment set up. Editor Setup See our recommended editors and learn how to set them up to work with React. Using TypeScript TypeScript is a popular way to add type definitions to JavaScript codebases. Learn how to integrate TypeScript into your React projects. React Developer Tools React Developer Tools is a browser extension that can inspect React components, edit props and state, and identify performance problems. Learn how to install it here. React Compiler React Compiler is a tool that automatically optimizes your React app. Learn more. Next steps Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day.PreviousAdd React to an Existing ProjectNextEditor SetupCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [],
      "chunks": [
        {
          "content": "Learn ReactSetupReact integrates with tools like editors, TypeScript, browser extensions, and compilers This section will help you get your environment set up Editor Setup See our recommended editors and learn how to set them up to work with React Using TypeScript TypeScript is a popular way to add type definitions to JavaScript codebases Learn how to integrate TypeScript into your React projects",
          "url": "https://react.dev/learn/setup",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "React Developer Tools React Developer Tools is a browser extension that can inspect React components, edit props and state, and identify performance problems Learn how to install it here React Compiler React Compiler is a tool that automatically optimizes your React app Learn more Next steps Head to the Quick Start guide for a tour of the most important React concepts you will encounter every day PreviousAdd React to an Existing ProjectNextEditor SetupCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/learn/setup",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/learn/setup",
          "library": "react",
          "chunk_id": "react_2"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/hooks",
      "title": "Built-in React Hooks \u2013 React",
      "content": "API ReferenceBuilt-in React HooksHooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React. State Hooks State lets a component remember information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index. To add state to a component, use one of these Hooks: useState declares a state variable that you can update directly. useReducer declares a state variable with the update logic inside a reducer function. function ImageGallery() { const [index, setIndex] = useState(0); // ... Context Hooks Context lets a component receive information from distant parents without passing it as props. For example, your apps top-level component can pass the current UI theme to all components below, no matter how deep. useContext reads and subscribes to a context. function Button() { const theme = useContext(ThemeContext); // ... Ref Hooks Refs let a component hold some information that isnt used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an escape hatch from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs. useRef declares a ref. You can hold any value in it, but most often its used to hold a DOM node. useImperativeHandle lets you customize the ref exposed by your component. This is rarely used. function Form() { const inputRef = useRef(null); // ... Effect Hooks Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code. useEffect connects a component to an external system. function ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(roomId); connection.connect(); return () = connection.disconnect(); }, [roomId]); // ... Effects are an escape hatch from the React paradigm. Dont use Effects to orchestrate the data flow of your application. If youre not interacting with an external system, you might not need an Effect. There are two rarely used variations of useEffect with differences in timing: useLayoutEffect fires before the browser repaints the screen. You can measure layout here. useInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here. Performance Hooks A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render. To skip calculations and unnecessary re-rendering, use one of these Hooks: useMemo lets you cache the result of an expensive calculation. useCallback lets you cache a function definition before passing it down to an optimized component. function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); // ...} Sometimes, you cant skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which dont need to block the user interface (like updating a chart). To prioritize rendering, use one of these Hooks: useTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it. useDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first. Other Hooks These Hooks are mostly useful to library authors and arent commonly used in the application code. useDebugValue lets you customize the label React DevTools displays for your custom Hook. useId lets a component associate a unique ID with itself. Typically used with accessibility APIs. useSyncExternalStore lets a component subscribe to an external store. useActionState allows you to manage state of actions. Your own Hooks You can also define your own custom Hooks as JavaScript functions.PreviousOverviewNextuseActionStateCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "function ImageGallery() {  const [index, setIndex] = useState(0);  // ...",
        "function ImageGallery() {  const [index, setIndex] = useState(0);  // ...",
        "function Button() {  const theme = useContext(ThemeContext);  // ...",
        "function Button() {  const theme = useContext(ThemeContext);  // ...",
        "useImperativeHandle",
        "function Form() {  const inputRef = useRef(null);  // ...",
        "function Form() {  const inputRef = useRef(null);  // ...",
        "function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  // ...",
        "function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  // ...",
        "useLayoutEffect",
        "useInsertionEffect",
        "useCallback",
        "function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}",
        "function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}",
        "useTransition",
        "useDeferredValue",
        "useDebugValue",
        "useSyncExternalStore",
        "useActionState"
      ],
      "chunks": [
        {
          "content": "API ReferenceBuilt-in React HooksHooks let you use different React features from your components You can either use the built-in Hooks or combine them to build your own This page lists all built-in Hooks in React State Hooks State lets a component remember information like user input For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "To add state to a component, use one of these Hooks: useState declares a state variable that you can update directly useReducer declares a state variable with the update logic inside a reducer function function ImageGallery() { const [index, setIndex] = useState(0); // Context Hooks Context lets a component receive information from distant parents without passing it as props For example, your apps top-level component can pass the current UI theme to all components below, no matter how deep",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "useContext reads and subscribes to a context function Button() { const theme = useContext(ThemeContext); // Ref Hooks Refs let a component hold some information that isnt used for rendering, like a DOM node or a timeout ID Unlike with state, updating a ref does not re-render your component Refs are an escape hatch from the React paradigm They are useful when you need to work with non-React systems, such as the built-in browser APIs useRef declares a ref",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "You can hold any value in it, but most often its used to hold a DOM node useImperativeHandle lets you customize the ref exposed by your component This is rarely used function Form() { const inputRef = useRef(null); // Effect Hooks Effects let a component connect to and synchronize with external systems This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code useEffect connects a component to an external system",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "function ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(roomId); connection connect(); return () = connection disconnect(); }, [roomId]); // Effects are an escape hatch from the React paradigm Dont use Effects to orchestrate the data flow of your application If youre not interacting with an external system, you might not need an Effect",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "There are two rarely used variations of useEffect with differences in timing: useLayoutEffect fires before the browser repaints the screen You can measure layout here useInsertionEffect fires before React makes changes to the DOM Libraries can insert dynamic CSS here Performance Hooks A common way to optimize re-rendering performance is to skip unnecessary work",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render To skip calculations and unnecessary re-rendering, use one of these Hooks: useMemo lets you cache the result of an expensive calculation useCallback lets you cache a function definition before passing it down to an optimized component function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); //",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "} Sometimes, you cant skip re-rendering because the screen actually needs to update In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which dont need to block the user interface (like updating a chart) To prioritize rendering, use one of these Hooks: useTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "useDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first Other Hooks These Hooks are mostly useful to library authors and arent commonly used in the application code useDebugValue lets you customize the label React DevTools displays for your custom Hook useId lets a component associate a unique ID with itself Typically used with accessibility APIs useSyncExternalStore lets a component subscribe to an external store",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "useActionState allows you to manage state of actions Your own Hooks You can also define your own custom Hooks as JavaScript functions PreviousOverviewNextuseActionStateCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/hooks",
          "library": "react",
          "chunk_id": "react_9"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useActionState",
      "title": "useActionState \u2013 React",
      "content": "API ReferenceHooksuseActionStateuseActionState is a Hook that allows you to update state based on the result of a form action.const [state, formAction, isPending] = useActionState(fn, initialState, permalink?); NoteIn earlier React Canary versions, this API was part of React DOM and called useFormState. Reference useActionState(action, initialState, permalink?) Usage Using information returned by a form action Troubleshooting My action can no longer read the submitted form data Reference useActionState(action, initialState, permalink?) Call useActionState at the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided. import { useActionState } from \"react\";async function increment(previousState, formData) { return previousState + 1;}function StatefulForm({}) { const [state, formAction] = useActionState(increment, 0); return ( form {state} button formAction={formAction}Increment/button /form )} The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass. If used with a Server Function, useActionState allows the servers response from submitting the form to be shown even before hydration has completed. See more examples below. Parameters fn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the initialState that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives. initialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked. optional permalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if fn is a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current pages URL. Ensure that the same form component is rendered on the destination page (including the same action fn and permalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect. Returns useActionState returns an array with the following values: The current state. During the first render, it will match the initialState you have passed. After the action is invoked, it will match the value returned by the action. A new action that you can pass as the action prop to your form component or formAction prop to any button component within the form. The action can also be called manually within startTransition. The isPending flag that tells you whether there is a pending Transition. Caveats When used with a framework that supports React Server Components, useActionState lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state. The function passed to useActionState receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using useActionState. Usage Using information returned by a form action Call useActionState at the top level of your component to access the return value of an action from the last time a form was submitted. import { useActionState } from 'react';import { action } from './actions.js';function MyComponent() { const [state, formAction] = useActionState(action, null); // ... return ( form action={formAction} {/* ... */} /form );} useActionState returns an array with the following items: The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided. A new action that you pass to form as its action prop or call manually within startTransition. A pending state that you can utilise while your action is processing. When the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form. The action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useActionState had not been used. function action(currentState, formData) { // ... return 'next state';} Display information after submitting a form1. Display form errors 2. Display structured information after submitting a form Example 1 of 2: Display form errors To display messages such as an error message or toast thats returned by a Server Function, wrap the action in a call to useActionState.App.jsactions.jsApp.js ResetForkimport { useActionState, useState } from \"react\"; import { addToCart } from \"./actions.js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( form action={formAction} h2{itemTitle}/h2 input type=\"hidden\" name=\"itemID\" value={itemID} / button type=\"submit\"Add to Cart/button {isPending ? \"Loading...\" : message} /form ); } export default function App() { return (  AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" / AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" / / ) } Show moreNext Example Troubleshooting My action can no longer read the submitted form data When you wrap an action with useActionState, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form. function action(currentState, formData) { // ...}PreviousHooksNextuseCallbackCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "useActionState",
        "const [state, formAction, isPending] = useActionState(fn, initialState, permalink?);",
        "const [state, formAction, isPending] = useActionState(fn, initialState, permalink?);",
        "useFormState",
        "useActionState(action, initialState, permalink?)",
        "useActionState(action, initialState, permalink?)",
        "useActionState",
        "useActionState",
        "import { useActionState } from \"react\";async function increment(previousState, formData) {  return previousState + 1;}function StatefulForm({}) {  const [state, formAction] = useActionState(increment, 0);  return (    <form>      {state}      <button formAction={formAction}>Increment</button>    </form>  )}",
        "import { useActionState } from \"react\";async function increment(previousState, formData) {  return previousState + 1;}function StatefulForm({}) {  const [state, formAction] = useActionState(increment, 0);  return (    <form>      {state}      <button formAction={formAction}>Increment</button>    </form>  )}",
        "useActionState",
        "initialState",
        "initialState",
        "useActionState",
        "initialState",
        "startTransition",
        "useActionState",
        "useActionState",
        "useActionState",
        "useActionState",
        "import { useActionState } from 'react';import { action } from './actions.js';function MyComponent() {  const [state, formAction] = useActionState(action, null);  // ...  return (    <form action={formAction}>      {/* ... */}    </form>  );}",
        "import { useActionState } from 'react';import { action } from './actions.js';function MyComponent() {  const [state, formAction] = useActionState(action, null);  // ...  return (    <form action={formAction}>      {/* ... */}    </form>  );}",
        "useActionState",
        "startTransition",
        "useActionState",
        "function action(currentState, formData) {  // ...  return 'next state';}",
        "function action(currentState, formData) {  // ...  return 'next state';}",
        "useActionState",
        "import { useActionState, useState } from \"react\";\nimport { addToCart } from \"./actions.js\";\n\nfunction AddToCartForm({itemID, itemTitle}) {\n  const [message, formAction, isPending] = useActionState(addToCart, null);\n  return (\n    <form action={formAction}>\n      <h2>{itemTitle}</h2>\n      <input type=\"hidden\" name=\"itemID\" value={itemID} />\n      <button type=\"submit\">Add to Cart</button>\n      {isPending ? \"Loading...\" : message}\n    </form>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" />\n      <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" />\n    </>\n  )\n}",
        "useActionState",
        "function action(currentState, formData) {  // ...}",
        "function action(currentState, formData) {  // ...}"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseActionStateuseActionState is a Hook that allows you to update state based on the result of a form action const [state, formAction, isPending] = useActionState(fn, initialState, permalink ); NoteIn earlier React Canary versions, this API was part of React DOM and called useFormState Reference useActionState(action, initialState, permalink",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": ") Usage Using information returned by a form action Troubleshooting My action can no longer read the submitted form data Reference useActionState(action, initialState, permalink ) Call useActionState at the top level of your component to create component state that is updated when a form action is invoked",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "You pass useActionState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending The latest form state is also passed to the function that you provided",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "import { useActionState } from \"react\";async function increment(previousState, formData) { return previousState + 1;}function StatefulForm({}) { const [state, formAction] = useActionState(increment, 0); return ( form {state} button formAction={formAction}Increment/button /form )} The form state is the value returned by the action when the form was last submitted If the form has not yet been submitted, it is the initial state that you pass",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "If used with a Server Function, useActionState allows the servers response from submitting the form to be shown even before hydration has completed See more examples below Parameters fn: The function to be called when the form is submitted or button pressed",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "When the function is called, it will receive the previous state of the form (initially the initialState that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives initialState: The value you want the state to be initially It can be any serializable value This argument is ignored after the action is first invoked optional permalink: A string containing the unique page URL that this form modifies",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if fn is a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current pages URL Ensure that the same form component is rendered on the destination page (including the same action fn and permalink) so that React knows how to pass the state through",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "Once the form has been hydrated, this parameter has no effect Returns useActionState returns an array with the following values: The current state During the first render, it will match the initialState you have passed After the action is invoked, it will match the value returned by the action A new action that you can pass as the action prop to your form component or formAction prop to any button component within the form The action can also be called manually within startTransition",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "The isPending flag that tells you whether there is a pending Transition Caveats When used with a framework that supports React Server Components, useActionState lets you make forms interactive before JavaScript has executed on the client When used without Server Components, it is equivalent to component local state The function passed to useActionState receives an extra argument, the previous or initial state, as its first argument",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "This makes its signature different than if it were used directly as a form action without using useActionState Usage Using information returned by a form action Call useActionState at the top level of your component to access the return value of an action from the last time a form was submitted import { useActionState } from 'react';import { action } from ' /actions js';function MyComponent() { const [state, formAction] = useActionState(action, null); // return ( form action={formAction} {/*",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "*/} /form );} useActionState returns an array with the following items: The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided A new action that you pass to form as its action prop or call manually within startTransition A pending state that you can utilise while your action is processing When the form is submitted, the action function that you provided will be called",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "Its return value will become the new current state of the form The action that you provide will also receive a new first argument, namely the current state of the form The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called The rest of the arguments are the same as if useActionState had not been used function action(currentState, formData) { //",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "return 'next state';} Display information after submitting a form1 Display form errors 2 Display structured information after submitting a form Example 1 of 2: Display form errors To display messages such as an error message or toast thats returned by a Server Function, wrap the action in a call to useActionState App jsactions jsApp js ResetForkimport { useActionState, useState } from \"react\"; import { addToCart } from \" /actions",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( form action={formAction} h2{itemTitle}/h2 input type=\"hidden\" name=\"itemID\" value={itemID} / button type=\"submit\"Add to Cart/button {isPending \"Loading",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "\" : message} /form ); } export default function App() { return (  AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" / AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" / / ) } Show moreNext Example Troubleshooting My action can no longer read the submitted form data When you wrap an action with useActionState, it gets an extra argument as its first argument The submitted form data is therefore its second argument instead of its first as it would usually be",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "The new first argument that gets added is the current state of the form function action(currentState, formData) { // }PreviousHooksNextuseCallbackCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useActionState",
          "library": "react",
          "chunk_id": "react_15"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useCallback",
      "title": "useCallback \u2013 React",
      "content": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders.const cachedFn = useCallback(fn, dependencies) Reference useCallback(fn, dependencies) Usage Skipping re-rendering of components Updating state from a memoized callback Preventing an Effect from firing too often Optimizing a custom Hook Troubleshooting Every time my component renders, useCallback returns a different function I need to call useCallback for each list item in a loop, but its not allowed Reference useCallback(fn, dependencies) Call useCallback at the top level of your component to cache a function definition between re-renders: import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); See more examples below. Parameters fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. Returns On the initial render, useCallback returns the fn function you have passed. During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies havent changed), or return the fn function you have passed during this render. Caveats useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate. Usage Skipping re-rendering of components When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Lets first look at the syntax for how to do this, and then see in which cases its useful. To cache a function between re-renders of your component, wrap its definition into the useCallback Hook: import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ... You need to pass two things to useCallback: A function definition that you want to cache between re-renders. A list of dependencies including every value within your component thats used inside your function. On the initial render, the returned function youll get from useCallback will be the function you passed. On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render. In other words, useCallback caches a function between re-renders until its dependencies change. Lets walk through an example to see when this is useful. Say youre passing a handleSubmit function down from the ProductPage to the ShippingForm component: function ProductPage({ productId, referrer, theme }) { // ... return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove ShippingForm / from your JSX, it feels fast. This tells you that its worth trying to optimize the ShippingForm component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that dont require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) { // ...}); With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Lets say you defined handleSubmit without useCallback: function ProductPage({ productId, referrer, theme }) { // Every time the theme changes, this will be a different function... function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails, }); } return ( div className={theme} {/* ... so ShippingForm's props will never be the same, and it will re-render every time */} ShippingForm onSubmit={handleSubmit} / /div );} In JavaScript, a function () {} or () = {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldnt be a problem, but it means that ShippingForm props will never be the same, and your memo optimization wont work. This is where useCallback comes in handy: function ProductPage({ productId, referrer, theme }) { // Tell React to cache your function between re-renders... const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ...so as long as these dependencies don't change... return ( div className={theme} {/* ...ShippingForm will receive the same props and can skip re-rendering */} ShippingForm onSubmit={handleSubmit} / /div );} By wrapping handleSubmit in useCallback, you ensure that its the same function between the re-renders (until dependencies change). You dont have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page. NoteYou should only rely on useCallback as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add useCallback back. Deep DiveHow is useCallback related to useMemo? Show DetailsYou will often see useMemo alongside useCallback. They are both useful when youre trying to optimize a child component. They let you memoize (or, in other words, cache) something youre passing down:import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) { const product = useData('/product/' + productId); const requirements = useMemo(() = { // Calls your function and caches its result return computeRequirements(product); }, [product]); const handleSubmit = useCallback((orderDetails) = { // Caches your function itself post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm requirements={requirements} onSubmit={handleSubmit} / /div );}The difference is in what theyre letting you cache: useMemo caches the result of calling your function. In this example, it caches the result of calling computeRequirements(product) so that it doesnt change unless product has changed. This lets you pass the requirements object down without unnecessarily re-rendering ShippingForm. When necessary, React will call the function youve passed during rendering to calculate the result. useCallback caches the function itself. Unlike useMemo, it does not call the function you provide. Instead, it caches the function you provided so that handleSubmit itself doesnt change unless productId or referrer has changed. This lets you pass the handleSubmit function down without unnecessarily re-rendering ShippingForm. Your code wont run until the user submits the form. If youre already familiar with useMemo, you might find it helpful to think of useCallback as this:// Simplified implementation (inside React)function useCallback(fn, dependencies) { return useMemo(() = fn, dependencies);}Read more about the difference between useMemo and useCallback. Deep DiveShould you add useCallback everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Caching a function with useCallback is only valuable in a few cases: You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasnt changed. Memoization lets your component re-render only if dependencies changed. The function youre passing is later used as a dependency of some Hook. For example, another function wrapped in useCallback depends on it, or you depend on this function from useEffect. There is no benefit to wrapping a function in useCallback in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.Note that useCallback does not prevent creating the function. Youre always creating a function (and thats fine!), but React ignores it and gives you back a cached function if nothing changed.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. Dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In long term, were researching doing memoization automatically to solve this once and for all. The difference between useCallback and declaring a function directly1. Skipping re-rendering with useCallback and memo 2. Always re-rendering a component Example 1 of 2: Skipping re-rendering with useCallback and memo In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow. Try incrementing the counter and toggling the theme.Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. Thats expected because the counter has changed, and so you need to reflect the users new choice on the screen.Next, try toggling the theme. Thanks to useCallback together with memo, its fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) havent changed since last render.App.jsProductPage.jsShippingForm.jsProductPage.js ResetForkimport { useCallback } from 'react'; import ShippingForm from './ShippingForm.js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); } function post(url, data) { // Imagine this sends a request... console.log('POST /' + url); console.log(data); } Show moreNext Example Updating state from a memoized callback Sometimes, you might need to update state based on previous state from a memoized callback. This handleAddTodo function specifies todos as a dependency because it computes the next todos from it: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos([...todos, newTodo]); }, [todos]); // ... Youll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos(todos = [...todos, newTodo]); }, []); //  No need for the todos dependency // ... Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos = [...todos, newTodo]) to React. Read more about updater functions. Preventing an Effect from firing too often Sometimes, you might want to call a function from inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: roomId }; } useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); // ... This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Problem: This dependency changes on every render // ... To solve this, you can wrap the function you need to call from an Effect into useCallback: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const createOptions = useCallback(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Only changes when createOptions changes // ... This ensures that the createOptions function is the same between re-renders if the roomId is the same. However, its even better to remove the need for a function dependency. Move your function inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { //  No need for useCallback or function dependencies! return { serverUrl: 'https://localhost:1234', roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  Only changes when roomId changes // ... Now your code is simpler and doesnt need useCallback. Learn more about removing Effect dependencies. Optimizing a custom Hook If youre writing a custom Hook, its recommended to wrap any functions that it returns into useCallback: function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback((url) = { dispatch({ type: 'navigate', url }); }, [dispatch]); const goBack = useCallback(() = { dispatch({ type: 'back' }); }, [dispatch]); return { navigate, goBack, };} This ensures that the consumers of your Hook can optimize their own code when needed. Troubleshooting Every time my component renders, useCallback returns a different function Make sure youve specified the dependency array as a second argument! If you forget the dependency array, useCallback will return a new function every time: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }); //  Returns a new function every time: no dependency array // ... This is the corrected version passing the dependency array as a second argument: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); //  Does not return a new function unnecessarily // ... If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console: const handleSubmit = useCallback((orderDetails) = { // .. }, [productId, referrer]); console.log([productId, referrer]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well. I need to call useCallback for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you cant call useCallback in a loop: function ReportList({ items }) { return ( article {items.map(item = { //  You can't call useCallback in a loop like this: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure key={item.id} Chart onClick={handleClick} / /figure ); })} /article );} Instead, extract a component for an individual item, and put useCallback there: function ReportList({ items }) { return ( article {items.map(item = Report key={item.id} item={item} / )} /article );}function Report({ item }) { //  Call useCallback at the top level: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure Chart onClick={handleClick} / /figure );} Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { // ...}const Report = memo(function Report({ item }) { function handleClick() { sendReport(item); } return ( figure Chart onClick={handleClick} / /figure );});PrevioususeActionStateNextuseContextCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "useCallback",
        "const cachedFn = useCallback(fn, dependencies)",
        "const cachedFn = useCallback(fn, dependencies)",
        "useCallback(fn, dependencies)",
        "useCallback",
        "useCallback",
        "useCallback(fn, dependencies)",
        "useCallback",
        "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);",
        "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);",
        "dependencies",
        "dependencies",
        "[dep1, dep2, dep3]",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ...",
        "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ...",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "handleSubmit",
        "ProductPage",
        "ShippingForm",
        "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );",
        "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );",
        "<ShippingForm />",
        "ShippingForm",
        "ProductPage",
        "ShippingForm",
        "ShippingForm",
        "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});",
        "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});",
        "ShippingForm",
        "handleSubmit",
        "useCallback",
        "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
        "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
        "function () {}",
        "ShippingForm",
        "useCallback",
        "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
        "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}",
        "handleSubmit",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}",
        "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}",
        "computeRequirements(product)",
        "requirements",
        "ShippingForm",
        "useCallback",
        "handleSubmit",
        "handleSubmit",
        "ShippingForm",
        "useCallback",
        "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}",
        "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "useCallback",
        "ShippingForm",
        "ShippingForm",
        "useCallback",
        "ShippingForm",
        "handleSubmit",
        "handleSubmit",
        "useCallback",
        "import { useCallback } from 'react';\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n  const handleSubmit = useCallback((orderDetails) => {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails,\n    });\n  }, [productId, referrer]);\n\n  return (\n    <div className={theme}>\n      <ShippingForm onSubmit={handleSubmit} />\n    </div>\n  );\n}\n\nfunction post(url, data) {\n  // Imagine this sends a request...\n  console.log('POST /' + url);\n  console.log(data);\n}",
        "handleAddTodo",
        "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ...",
        "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ...",
        "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // \u2705 No need for the todos dependency  // ...",
        "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // \u2705 No need for the todos dependency  // ...",
        "todos => [...todos, newTodo]",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ...",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ...",
        "createOptions",
        "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \ud83d\udd34 Problem: This dependency changes on every render  // ...",
        "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \ud83d\udd34 Problem: This dependency changes on every render  // ...",
        "useCallback",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // \u2705 Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \u2705 Only changes when createOptions changes  // ...",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // \u2705 Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \u2705 Only changes when createOptions changes  // ...",
        "createOptions",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // \u2705 No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // \u2705 Only changes when roomId changes  // ...",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // \u2705 No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // \u2705 Only changes when roomId changes  // ...",
        "useCallback",
        "useCallback",
        "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}",
        "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}",
        "useCallback",
        "useCallback",
        "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // \ud83d\udd34 Returns a new function every time: no dependency array  // ...",
        "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // \ud83d\udd34 Returns a new function every time: no dependency array  // ...",
        "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // \u2705 Does not return a new function unnecessarily  // ...",
        "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // \u2705 Does not return a new function unnecessarily  // ...",
        "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);",
        "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);",
        "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...",
        "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...",
        "useCallback",
        "useCallback",
        "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // \ud83d\udd34 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}",
        "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // \ud83d\udd34 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}",
        "useCallback",
        "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // \u2705 Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}",
        "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // \u2705 Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}",
        "useCallback",
        "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});",
        "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "const cachedFn = useCallback(fn, dependencies) Reference useCallback(fn, dependencies) Usage Skipping re-rendering of components Updating state from a memoized callback Preventing an Effect from firing too often Optimizing a custom Hook Troubleshooting Every time my component renders, useCallback returns a different function I need to call useCallback for each list item in a loop, but its not allowed Reference useCallback(fn, dependencies) Call useCallback at the top level of your component to cache a function definition between re-renders: import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); See more examples below",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Parameters fn: The function value that you want to cache It can take any arguments and return any values React will return (not call ) your function back to you during the initial render On next renders, React will give you the same function again if the dependencies have not changed since the last render Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later React will not call your function",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "The function is returned to you so you can decide when and whether to call it dependencies: The list of all reactive values referenced inside of the fn code Reactive values include props, state, and all the variables and functions declared directly inside your component body If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3] React will compare each dependency with its previous value using the Object is comparison algorithm Returns On the initial render, useCallback returns the fn function you have passed During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies havent changed), or return the fn function you have passed during this render",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "Caveats useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks You cant call it inside loops or conditions If you need that, extract a new component and move the state into it React will not throw away the cached function unless there is a specific reason to do that For example, in development, React throws away the cache when you edit the file of your component",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "Both in development and in production, React will throw away the cache if your component suspends during the initial mount In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport This should match your expectations if you rely on useCallback as a performance optimization",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "Otherwise, a state variable or a ref may be more appropriate Usage Skipping re-rendering of components When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components Lets first look at the syntax for how to do this, and then see in which cases its useful",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "To cache a function between re-renders of your component, wrap its definition into the useCallback Hook: import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // You need to pass two things to useCallback: A function definition that you want to cache between re-renders",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "A list of dependencies including every value within your component thats used inside your function On the initial render, the returned function youll get from useCallback will be the function you passed On the following renders, React will compare the dependencies with the dependencies you passed during the previous render If none of the dependencies have changed (compared with Object is), useCallback will return the same function as before",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "Otherwise, useCallback will return the function you passed on this render In other words, useCallback caches a function between re-renders until its dependencies change Lets walk through an example to see when this is useful Say youre passing a handleSubmit function down from the ProductPage to the ShippingForm component: function ProductPage({ productId, referrer, theme }) { //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove ShippingForm / from your JSX, it feels fast This tells you that its worth trying to optimize the ShippingForm component By default, when a component re-renders, React re-renders all of its children recursively This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "This is fine for components that dont require much calculation to re-render But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) { // }); With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render This is when caching a function becomes important",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Lets say you defined handleSubmit without useCallback: function ProductPage({ productId, referrer, theme }) { // Every time the theme changes, this will be a different function function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails, }); } return ( div className={theme} {/*",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "so ShippingForm's props will never be the same, and it will re-render every time */} ShippingForm onSubmit={handleSubmit} / /div );} In JavaScript, a function () {} or () = {} always creates a different function, similar to how the {} object literal always creates a new object Normally, this wouldnt be a problem, but it means that ShippingForm props will never be the same, and your memo optimization wont work",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "This is where useCallback comes in handy: function ProductPage({ productId, referrer, theme }) { // Tell React to cache your function between re-renders const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // so as long as these dependencies don't change return ( div className={theme} {/*",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "ShippingForm will receive the same props and can skip re-rendering */} ShippingForm onSubmit={handleSubmit} / /div );} By wrapping handleSubmit in useCallback, you ensure that its the same function between the re-renders (until dependencies change) You dont have to wrap a function in useCallback unless you do it for some specific reason In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "There are other reasons you might need useCallback which are described further on this page NoteYou should only rely on useCallback as a performance optimization If your code doesnt work without it, find the underlying problem and fix it first Then you may add useCallback back Deep DiveHow is useCallback related to useMemo Show DetailsYou will often see useMemo alongside useCallback They are both useful when youre trying to optimize a child component",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "They let you memoize (or, in other words, cache) something youre passing down:import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) { const product = useData('/product/' + productId); const requirements = useMemo(() = { // Calls your function and caches its result return computeRequirements(product); }, [product]); const handleSubmit = useCallback((orderDetails) = { // Caches your function itself post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm requirements={requirements} onSubmit={handleSubmit} / /div );}The difference is in what theyre letting you cache: useMemo caches the result of calling your function",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "In this example, it caches the result of calling computeRequirements(product) so that it doesnt change unless product has changed This lets you pass the requirements object down without unnecessarily re-rendering ShippingForm When necessary, React will call the function youve passed during rendering to calculate the result useCallback caches the function itself Unlike useMemo, it does not call the function you provide",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "Instead, it caches the function you provided so that handleSubmit itself doesnt change unless productId or referrer has changed This lets you pass the handleSubmit function down without unnecessarily re-rendering ShippingForm Your code wont run until the user submits the form",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "If youre already familiar with useMemo, you might find it helpful to think of useCallback as this:// Simplified implementation (inside React)function useCallback(fn, dependencies) { return useMemo(() = fn, dependencies);}Read more about the difference between useMemo and useCallback Deep DiveShould you add useCallback everywhere Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful Caching a function with useCallback is only valuable in a few cases: You pass it as a prop to a component wrapped in memo You want to skip re-rendering if the value hasnt changed Memoization lets your component re-render only if dependencies changed The function youre passing is later used as a dependency of some Hook",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "For example, another function wrapped in useCallback depends on it, or you depend on this function from useEffect There is no benefit to wrapping a function in useCallback in other cases There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible The downside is that code becomes less readable",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component Note that useCallback does not prevent creating the function Youre always creating a function (and thats fine ), but React ignores it and gives you back a cached function if nothing changed In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "Then, if the wrapper component updates its own state, React knows that its children dont need to re-render Prefer local state and dont lift state up any further than necessary Dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library Keep your rendering logic pure If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component Fix the bug instead of adding memoization",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "Avoid unnecessary Effects that update state Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over Try to remove unnecessary dependencies from your Effects For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed These principles make your components easier to debug and understand, so its good to follow them in any case In long term, were researching doing memoization automatically to solve this once and for all The difference between useCallback and declaring a function directly1 Skipping re-rendering with useCallback and memo 2",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "Always re-rendering a component Example 1 of 2: Skipping re-rendering with useCallback and memo In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow Try incrementing the counter and toggling the theme Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "Thats expected because the counter has changed, and so you need to reflect the users new choice on the screen Next, try toggling the theme Thanks to useCallback together with memo, its fast despite the artificial slowdown ShippingForm skipped re-rendering because the handleSubmit function has not changed The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) havent changed since last render App jsProductPage jsShippingForm jsProductPage",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "js ResetForkimport { useCallback } from 'react'; import ShippingForm from ' /ShippingForm js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); } function post(url, data) { // Imagine this sends a request console log('POST /' + url); console",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_30"
        },
        {
          "content": "log(data); } Show moreNext Example Updating state from a memoized callback Sometimes, you might need to update state based on previous state from a memoized callback This handleAddTodo function specifies todos as a dependency because it computes the next todos from it: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos([ todos, newTodo]); }, [todos]); //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_31"
        },
        {
          "content": "Youll usually want memoized functions to have as few dependencies as possible When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos(todos = [ todos, newTodo]); }, []); //  No need for the todos dependency //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_32"
        },
        {
          "content": "Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos = [ todos, newTodo]) to React Read more about updater functions",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_33"
        },
        {
          "content": "Preventing an Effect from firing too often Sometimes, you might want to call a function from inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: roomId }; } useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection connect(); // This creates a problem Every reactive value must be declared as a dependency of your Effect",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_34"
        },
        {
          "content": "However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection connect(); return () = connection disconnect(); }, [createOptions]); //  Problem: This dependency changes on every render //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_35"
        },
        {
          "content": "To solve this, you can wrap the function you need to call from an Effect into useCallback: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const createOptions = useCallback(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_36"
        },
        {
          "content": "disconnect(); }, [createOptions]); //  Only changes when createOptions changes // This ensures that the createOptions function is the same between re-renders if the roomId is the same However, its even better to remove the need for a function dependency Move your function inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { //  No need for useCallback or function dependencies",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_37"
        },
        {
          "content": "return { serverUrl: 'https://localhost:1234', roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection connect(); return () = connection disconnect(); }, [roomId]); //  Only changes when roomId changes // Now your code is simpler and doesnt need useCallback Learn more about removing Effect dependencies",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_38"
        },
        {
          "content": "Optimizing a custom Hook If youre writing a custom Hook, its recommended to wrap any functions that it returns into useCallback: function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback((url) = { dispatch({ type: 'navigate', url }); }, [dispatch]); const goBack = useCallback(() = { dispatch({ type: 'back' }); }, [dispatch]); return { navigate, goBack, };} This ensures that the consumers of your Hook can optimize their own code when needed",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_39"
        },
        {
          "content": "Troubleshooting Every time my component renders, useCallback returns a different function Make sure youve specified the dependency array as a second argument If you forget the dependency array, useCallback will return a new function every time: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }); //  Returns a new function every time: no dependency array //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_40"
        },
        {
          "content": "This is the corrected version passing the dependency array as a second argument: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); //  Does not return a new function unnecessarily // If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_41"
        },
        {
          "content": "You can debug this problem by manually logging your dependencies to the console: const handleSubmit = useCallback((orderDetails) = { // }, [productId, referrer]); console log([productId, referrer]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_42"
        },
        {
          "content": "Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays Object is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays Object is(temp1[2], temp2[2]); // and so on for every dependency",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_43"
        },
        {
          "content": "When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well I need to call useCallback for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo You want to skip re-rendering every Chart in the list when the ReportList component re-renders However, you cant call useCallback in a loop: function ReportList({ items }) { return ( article {items",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_44"
        },
        {
          "content": "map(item = { //  You can't call useCallback in a loop like this: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure key={item id} Chart onClick={handleClick} / /figure ); })} /article );} Instead, extract a component for an individual item, and put useCallback there: function ReportList({ items }) { return ( article {items map(item = Report key={item",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_45"
        },
        {
          "content": "id} item={item} / )} /article );}function Report({ item }) { //  Call useCallback at the top level: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure Chart onClick={handleClick} / /figure );} Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { //",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_46"
        },
        {
          "content": "}const Report = memo(function Report({ item }) { function handleClick() { sendReport(item); } return ( figure Chart onClick={handleClick} / /figure );});PrevioususeActionStateNextuseContextCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useCallback",
          "library": "react",
          "chunk_id": "react_47"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useContext",
      "title": "useContext \u2013 React",
      "content": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesnt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that youve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding Context needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( ThemeContext value=\"dark\" Form / /ThemeContext );}function Form() { // ... renders buttons inside ...} It doesnt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which youre calling useContext(). App.jsApp.js ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show more Updating data passed via context Often, youll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( ThemeContext value={theme} Form / Button onClick={() = { setTheme('light'); }} Switch to light theme /Button /ThemeContext );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the Dark mode checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.js ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( ThemeContext value={theme} Form / label input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) = { setTheme(e.target.checked ? 'dark' : 'light') }} / Use dark mode /label /ThemeContext ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that arent strings.Next Example Specifying a fallback default value If React cant find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it wont break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the Toggle theme button is always light because its outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.js ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return (  ThemeContext value={theme} Form / /ThemeContext Button onClick={() = { setTheme(theme === 'dark' ? 'light' : 'dark'); }} Toggle theme /Button / ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} onClick={onClick} {children} /button ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. ThemeContext value=\"dark\" ... ThemeContext value=\"light\" Footer / /ThemeContext .../ThemeContext You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.js ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button ThemeContext value=\"light\" Footer / /ThemeContext /Panel ); } function Footer() { return ( footer ButtonSettings/Button /footer ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} {title  h1{title}/h1} {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( AuthContext value={{ currentUser, login }} Page / /AuthContext );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) = { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() = ({ currentUser, login }), [currentUser, login]); return ( AuthContext value={contextValue} Page / /AuthContext );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) wont need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesnt see the value from my provider There are a few common ways that this can happen: Youre rendering SomeContext in the same component (or below) as where youre calling useContext(). Move SomeContext above and outside the component calling useContext(). You may have forgotten to wrap your component with SomeContext, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If theyre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: //  Doesn't work: no value propThemeContext Button //ThemeContext If you forget to specify value, its like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: //  Doesn't work: prop should be called \"value\"ThemeContext theme={theme} Button //ThemeContext In both of these cases you should see a warning from React in the console. To fix them, call the prop value: //  Passing the value propThemeContext value={theme} Button //ThemeContext Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a SomeContext value={undefined} component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.PrevioususeCallbackNextuseDebugValueCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "const value = useContext(SomeContext)",
        "const value = useContext(SomeContext)",
        "useContext(SomeContext)",
        "useContext(SomeContext)",
        "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ...",
        "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ...",
        "SomeContext",
        "createContext",
        "SomeContext",
        "defaultValue",
        "createContext",
        "useContext()",
        "useContext()",
        "SomeContext",
        "SomeContext",
        "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ...",
        "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ...",
        "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}",
        "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}",
        "useContext(ThemeContext)",
        "useContext()",
        "useContext()",
        "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}",
        "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}",
        "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}",
        "ThemeContext",
        "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext value={theme}>\n      <Form />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={theme === 'dark'}\n          onChange={(e) => {\n            setTheme(e.target.checked ? 'dark' : 'light')\n          }}\n        />\n        Use dark mode\n      </label>\n    </ThemeContext>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}",
        "value=\"dark\"",
        "value={theme}",
        "useContext()",
        "const ThemeContext = createContext(null);",
        "const ThemeContext = createContext(null);",
        "const ThemeContext = createContext('light');",
        "const ThemeContext = createContext('light');",
        "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <>\n      <ThemeContext value={theme}>\n        <Form />\n      </ThemeContext>\n      <Button onClick={() => {\n        setTheme(theme === 'dark' ? 'light' : 'dark');\n      }}>\n        Toggle theme\n      </Button>\n    </>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children, onClick }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className} onClick={onClick}>\n      {children}\n    </button>\n  );\n}",
        "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>",
        "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>",
        "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n      <ThemeContext value=\"light\">\n        <Footer />\n      </ThemeContext>\n    </Panel>\n  );\n}\n\nfunction Footer() {\n  return (\n    <footer>\n      <Button>Settings</Button>\n    </footer>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      {title && <h1>{title}</h1>}\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}",
        "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}",
        "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}",
        "useContext(AuthContext)",
        "currentUser",
        "useCallback",
        "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}",
        "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}",
        "useContext(AuthContext)",
        "currentUser",
        "useCallback",
        "<SomeContext>",
        "useContext()",
        "<SomeContext>",
        "useContext()",
        "<SomeContext>",
        "SomeContext",
        "SomeContext",
        "window.SomeContext1",
        "window.SomeContext2",
        "window.SomeContext1 === window.SomeContext2",
        "// \ud83d\udea9 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>",
        "// \ud83d\udea9 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>",
        "value={undefined}",
        "// \ud83d\udea9 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>",
        "// \ud83d\udea9 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>",
        "// \u2705 Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>",
        "// \u2705 Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>",
        "createContext(defaultValue)",
        "<SomeContext value={undefined}>",
        "useContext(SomeContext)"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesnt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // See more examples below Parameters SomeContext: The context that youve previously created with createContext The context itself does not hold the information, it only represents the kind of information you can provide or read from components Returns useContext returns the context value for the calling component",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "It is determined as the value passed to the closest SomeContext above the calling component in the tree If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context The returned value is always up-to-date React automatically re-renders components that read some context if it changes Caveats useContext() call in a component is not affected by providers returned from the same component",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "The corresponding Context needs to be above the component doing the useContext() call React automatically re-renders all the children that use a particular context starting from the provider that receives a different value The previous and the next values are compared with the Object is comparison Skipping re-renders with memo does not prevent the children receiving fresh context values",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // useContext returns the context value for the context you passed To determine the context value, React searches the component tree and finds the closest context provider above for that particular context",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( ThemeContext value=\"dark\" Form / /ThemeContext );}function Form() { // renders buttons inside } It doesnt matter how many layers of components there are between the provider and the Button When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "PitfalluseContext() always looks for the closest provider above the component that calls it It searches upwards and does not consider providers in the component from which youre calling useContext() App jsApp",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "js ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show more Updating data passed via context Often, youll want the context to change over time",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "To update context, combine it with state Declare a state variable in the parent component, and pass the current state down as the context value to the provider function MyPage() { const [theme, setTheme] = useState('dark'); return ( ThemeContext value={theme} Form / Button onClick={() = { setTheme('light'); }} Switch to light theme /Button /ThemeContext );} Now any Button inside of the provider will receive the current theme value",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value Examples of updating context1 Updating a value via context 2 Updating an object via context 3 Multiple contexts 4 Extracting providers to a component 5 Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "Checking the Dark mode checkbox updates the state Changing the provided value re-renders all the components using that context App jsApp js ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( ThemeContext value={theme} Form / label input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) = { setTheme(e target checked",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "'dark' : 'light') }} / Use dark mode /label /ThemeContext ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Curly braces also let you pass context values that arent strings Next Example Specifying a fallback default value If React cant find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes If you want to update context, use it with state as described above",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it wont break This also helps your components work well in a test environment without setting up a lot of providers in the tests",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "In the example below, the Toggle theme button is always light because its outside any theme context provider and the default context theme value is 'light' Try editing the default theme to be 'dark' App jsApp",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "js ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return (  ThemeContext value={theme} Form / /ThemeContext Button onClick={() = { setTheme(theme === 'dark'",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "'light' : 'dark'); }} Toggle theme /Button / ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} onClick={onClick} {children} /button ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "ThemeContext value=\"dark\" ThemeContext value=\"light\" Footer / /ThemeContext /ThemeContext You can nest and override providers as many times as you need Examples of overriding context1 Overriding a theme 2 Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\") App jsApp",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "js ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button ThemeContext value=\"light\" Footer / /ThemeContext /Panel ); } function Footer() { return ( footer ButtonSettings/Button /footer ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} {title  h1{title}/h1} {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response credentials); setCurrentUser(response user); } return ( AuthContext value={{ currentUser, login }} Page / /AuthContext );} Here, the context value is a JavaScript object with two properties, one of which is a function",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext) In smaller apps, this is not a problem However, there is no need to re-render them if the underlying data, like currentUser, has not changed",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) = { storeCredentials(response credentials); setCurrentUser(response",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "user); }, []); const contextValue = useMemo(() = ({ currentUser, login }), [currentUser, login]); return ( AuthContext value={contextValue} Page / /AuthContext );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) wont need to re-render unless currentUser has changed Read more about useMemo and useCallback",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "Troubleshooting My component doesnt see the value from my provider There are a few common ways that this can happen: Youre rendering SomeContext in the same component (or below) as where youre calling useContext() Move SomeContext above and outside the component calling useContext() You may have forgotten to wrap your component with SomeContext, or you might have put it in a different part of the tree than you thought Check whether the hierarchy is right using React DevTools",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects This can happen if you use symlinks, for example You can verify this by assigning them to globals like window SomeContext1 and window SomeContext2 and then checking whether window SomeContext1 === window SomeContext2 in the console If theyre not the same, fix that issue on the build tool level",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: //  Doesn't work: no value propThemeContext Button //ThemeContext If you forget to specify value, its like passing value={undefined}",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "You may have also mistakingly used a different prop name by mistake: //  Doesn't work: prop should be called \"value\"ThemeContext theme={theme} Button //ThemeContext In both of these cases you should see a warning from React in the console To fix them, call the prop value: //  Passing the value propThemeContext value={theme} Button //ThemeContext Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "If there is a SomeContext value={undefined} component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value PrevioususeCallbackNextuseDebugValueCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useContext",
          "library": "react",
          "chunk_id": "react_30"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useDebugValue",
      "title": "useDebugValue \u2013 React",
      "content": "API ReferenceHooksuseDebugValueuseDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools.useDebugValue(value, format?) Reference useDebugValue(value, format?) Usage Adding a label to a custom Hook Deferring formatting of a debug value Reference useDebugValue(value, format?) Call useDebugValue at the top level of your custom Hook to display a readable debug value: import { useDebugValue } from 'react';function useOnlineStatus() { // ... useDebugValue(isOnline ? 'Online' : 'Offline'); // ...} See more examples below. Parameters value: The value you want to display in React DevTools. It can have any type. optional format: A formatting function. When the component is inspected, React DevTools will call the formatting function with the value as the argument, and then display the returned formatted value (which may have any type). If you dont specify the formatting function, the original value itself will be displayed. Returns useDebugValue does not return anything. Usage Adding a label to a custom Hook Call useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools. import { useDebugValue } from 'react';function useOnlineStatus() { // ... useDebugValue(isOnline ? 'Online' : 'Offline'); // ...} This gives components calling useOnlineStatus a label like OnlineStatus: \"Online\" when you inspect them: Without the useDebugValue call, only the underlying data (in this example, true) would be displayed. App.jsuseOnlineStatus.jsuseOnlineStatus.js ResetForkimport { useSyncExternalStore, useDebugValue } from 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, () = navigator.onLine, () = true); useDebugValue(isOnline ? 'Online' : 'Offline'); return isOnline; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () = { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Show more NoteDont add debug values to every custom Hook. Its most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure thats difficult to inspect. Deferring formatting of a debug value You can also pass a formatting function as the second argument to useDebugValue: useDebugValue(date, date = date.toDateString()); Your formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result. This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if date is a Date value, this avoids calling toDateString() on it for every render.PrevioususeContextNextuseDeferredValueCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "useDebugValue",
        "useDebugValue(value, format?)",
        "useDebugValue(value, format?)",
        "useDebugValue(value, format?)",
        "useDebugValue(value, format?)",
        "useDebugValue",
        "import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}",
        "import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}",
        "useDebugValue",
        "useDebugValue",
        "import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}",
        "import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}",
        "useOnlineStatus",
        "OnlineStatus: \"Online\"",
        "useDebugValue",
        "import { useSyncExternalStore, useDebugValue } from 'react';\n\nexport function useOnlineStatus() {\n  const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  return isOnline;\n}\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () => {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}",
        "useDebugValue",
        "useDebugValue(date, date => date.toDateString());",
        "useDebugValue(date, date => date.toDateString());",
        "toDateString()"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseDebugValueuseDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools useDebugValue(value, format ) Reference useDebugValue(value, format ) Usage Adding a label to a custom Hook Deferring formatting of a debug value Reference useDebugValue(value, format ) Call useDebugValue at the top level of your custom Hook to display a readable debug value: import { useDebugValue } from 'react';function useOnlineStatus() { // useDebugValue(isOnline",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "'Online' : 'Offline'); // } See more examples below Parameters value: The value you want to display in React DevTools It can have any type optional format: A formatting function When the component is inspected, React DevTools will call the formatting function with the value as the argument, and then display the returned formatted value (which may have any type) If you dont specify the formatting function, the original value itself will be displayed Returns useDebugValue does not return anything",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Usage Adding a label to a custom Hook Call useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools import { useDebugValue } from 'react';function useOnlineStatus() { // useDebugValue(isOnline 'Online' : 'Offline'); // } This gives components calling useOnlineStatus a label like OnlineStatus: \"Online\" when you inspect them: Without the useDebugValue call, only the underlying data (in this example, true) would be displayed App jsuseOnlineStatus",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "jsuseOnlineStatus js ResetForkimport { useSyncExternalStore, useDebugValue } from 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, () = navigator onLine, () = true); useDebugValue(isOnline 'Online' : 'Offline'); return isOnline; } function subscribe(callback) { window addEventListener('online', callback); window addEventListener('offline', callback); return () = { window removeEventListener('online', callback); window",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "removeEventListener('offline', callback); }; } Show more NoteDont add debug values to every custom Hook Its most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure thats difficult to inspect Deferring formatting of a debug value You can also pass a formatting function as the second argument to useDebugValue: useDebugValue(date, date = date",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "toDateString()); Your formatting function will receive the debug value as a parameter and should return a formatted display value When your component is inspected, React DevTools will call this function and display its result This lets you avoid running potentially expensive formatting logic unless the component is actually inspected For example, if date is a Date value, this avoids calling toDateString() on it for every render",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "PrevioususeContextNextuseDeferredValueCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useDebugValue",
          "library": "react",
          "chunk_id": "react_6"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useDeferredValue",
      "title": "useDeferredValue \u2013 React",
      "content": "API ReferenceHooksuseDeferredValueuseDeferredValue is a React Hook that lets you defer updating a part of the UI.const deferredValue = useDeferredValue(value) Reference useDeferredValue(value, initialValue?) Usage Showing stale content while fresh content is loading Indicating that the content is stale Deferring re-rendering for a part of the UI Reference useDeferredValue(value, initialValue?) Call useDeferredValue at the top level of your component to get a deferred version of that value. import { useState, useDeferredValue } from 'react';function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // ...} See more examples below. Parameters value: The value you want to defer. It can have any type. optional initialValue: A value to use during the initial render of a component. If this option is omitted, useDeferredValue will not defer during the initial render, because theres no previous version of value that it can render instead. Returns currentValue: During the initial render, the returned deferred value will be the initialValue, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value). Caveats When an update is inside a Transition, useDeferredValue always returns the new value and does not spawn a deferred render, since the update is already deferred. The values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders. When useDeferredValue receives a different value (compared with Object.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if theres another update to the value, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing. useDeferredValue is integrated with Suspense. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads. useDeferredValue does not by itself prevent extra network requests. There is no fixed delay caused by useDeferredValue itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it. The background re-render caused by useDeferredValue does not fire Effects until its committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates. Usage Showing stale content while fresh content is loading Call useDeferredValue at the top level of your component to defer updating some part of your UI. import { useState, useDeferredValue } from 'react';function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // ...} During the initial render, the deferred value will be the same as the value you provided. During updates, the deferred value will lag behind the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background. Lets walk through an example to see when this is useful. NoteThis example assumes you use a Suspense-enabled data source: Data fetching with Suspense-enabled frameworks like Relay and Next.js Lazy-loading component code with lazy Reading the value of a Promise with use Learn more about Suspense and its limitations. In this example, the SearchResults component suspends while fetching the search results. Try typing \"a\", waiting for the results, and then editing it to \"ab\". The results for \"a\" get replaced by the loading fallback. App.jsSearchResults.jsApp.js ResetForkimport { Suspense, useState } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={query} / /Suspense / ); } Show more A common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready. Call useDeferredValue to pass a deferred version of the query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={deferredQuery} / /Suspense / );} The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit. Enter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded: App.jsSearchResults.jsApp.js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={deferredQuery} / /Suspense / ); } Show more Deep DiveHow does deferring a value work under the hood? Show DetailsYou can think of it as happening in two steps: First, React re-renders with the new query (\"ab\") but with the old deferredQuery (still \"a\"). The deferredQuery value, which you pass to the result list, is deferred: it lags behind the query value. In the background, React tries to re-render with both query and deferredQuery updated to \"ab\". If this re-render completes, React will show it on the screen. However, if it suspends (the results for \"ab\" have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready. The deferred background rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.Note that there is still a network request per each keystroke. Whats being deferred here is displaying results (until theyre ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesnt fetch again. Indicating that the content is stale In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed: div style={{ opacity: query !== deferredQuery ? 0.5 : 1,}} SearchResults query={deferredQuery} //div With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below: App.jsSearchResults.jsApp.js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }} SearchResults query={deferredQuery} / /div /Suspense / ); } Show more Deferring re-rendering for a part of the UI You can also apply useDeferredValue as a performance optimization. It is useful when a part of your UI is slow to re-render, theres no easy way to optimize it, and you want to prevent it from blocking the rest of the UI. Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke: function App() { const [text, setText] = useState(''); return (  input value={text} onChange={e = setText(e.target.value)} / SlowList text={text} / / );} First, optimize SlowList to skip re-rendering when its props are the same. To do this, wrap it in memo: const SlowList = memo(function SlowList({ text }) { // ...}); However, this only helps if the SlowList props are the same as during the previous render. The problem youre facing now is that its slow when theyre different, and when you actually need to show different visual output. Concretely, the main performance problem is that whenever you type into the input, the SlowList receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, useDeferredValue lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower): function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return (  input value={text} onChange={e = setText(e.target.value)} / SlowList text={deferredText} / / );} This does not make re-rendering of the SlowList faster. However, it tells React that re-rendering the list can be deprioritized so that it doesnt block the keystrokes. The list will lag behind the input and then catch up. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing. The difference between useDeferredValue and unoptimized re-rendering1. Deferred re-rendering of the list 2. Unoptimized re-rendering of the list Example 1 of 2: Deferred re-rendering of the list In this example, each item in the SlowList component is artificially slowed down so that you can see how useDeferredValue lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list lags behind it.App.jsSlowList.jsApp.js ResetForkimport { useState, useDeferredValue } from 'react'; import SlowList from './SlowList.js'; export default function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return (  input value={text} onChange={e = setText(e.target.value)} / SlowList text={deferredText} / / ); } Next Example PitfallThis optimization requires SlowList to be wrapped in memo. This is because whenever the text changes, React needs to be able to re-render the parent component quickly. During that re-render, deferredText still has its previous value, so SlowList is able to skip re-rendering (its props have not changed). Without memo, it would have to re-render anyway, defeating the point of the optimization. Deep DiveHow is deferring a value different from debouncing and throttling? Show DetailsThere are two common optimization techniques you might have used before in this scenario: Debouncing means youd wait for the user to stop typing (e.g. for a second) before updating the list. Throttling means youd update the list every once in a while (e.g. at most once a second). While these techniques are helpful in some cases, useDeferredValue is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the users device.Unlike debouncing or throttling, it doesnt require choosing any fixed delay. If the users device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldnt be noticeable. If the users device is slow, the list would lag behind the input proportionally to how slow the device is.Also, unlike with debouncing or throttling, deferred re-renders done by useDeferredValue are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because theyre blocking: they merely postpone the moment when rendering blocks the keystroke.If the work youre optimizing doesnt happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.PrevioususeDebugValueNextuseEffectCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "useDeferredValue",
        "const deferredValue = useDeferredValue(value)",
        "const deferredValue = useDeferredValue(value)",
        "useDeferredValue(value, initialValue?)",
        "useDeferredValue(value, initialValue?)",
        "useDeferredValue",
        "import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}",
        "import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}",
        "initialValue",
        "useDeferredValue",
        "currentValue",
        "initialValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "useDeferredValue",
        "import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}",
        "import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}",
        "SearchResults",
        "import { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={query} />\n      </Suspense>\n    </>\n  );\n}",
        "useDeferredValue",
        "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}",
        "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}",
        "deferredQuery",
        "SearchResults",
        "import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={deferredQuery} />\n      </Suspense>\n    </>\n  );\n}",
        "deferredQuery",
        "deferredQuery",
        "deferredQuery",
        "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1,}}>  <SearchResults query={deferredQuery} /></div>",
        "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1,}}>  <SearchResults query={deferredQuery} /></div>",
        "import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <div style={{\n          opacity: isStale ? 0.5 : 1,\n          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'\n        }}>\n          <SearchResults query={deferredQuery} />\n        </div>\n      </Suspense>\n    </>\n  );\n}",
        "useDeferredValue",
        "function App() {  const [text, setText] = useState('');  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={text} />    </>  );}",
        "function App() {  const [text, setText] = useState('');  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={text} />    </>  );}",
        "const SlowList = memo(function SlowList({ text }) {  // ...});",
        "const SlowList = memo(function SlowList({ text }) {  // ...});",
        "useDeferredValue",
        "function App() {  const [text, setText] = useState('');  const deferredText = useDeferredValue(text);  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={deferredText} />    </>  );}",
        "function App() {  const [text, setText] = useState('');  const deferredText = useDeferredValue(text);  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={deferredText} />    </>  );}",
        "useDeferredValue",
        "import { useState, useDeferredValue } from 'react';\nimport SlowList from './SlowList.js';\n\nexport default function App() {\n  const [text, setText] = useState('');\n  const deferredText = useDeferredValue(text);\n  return (\n    <>\n      <input value={text} onChange={e => setText(e.target.value)} />\n      <SlowList text={deferredText} />\n    </>\n  );\n}",
        "deferredText",
        "useDeferredValue",
        "useDeferredValue"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseDeferredValueuseDeferredValue is a React Hook that lets you defer updating a part of the UI const deferredValue = useDeferredValue(value) Reference useDeferredValue(value, initialValue ) Usage Showing stale content while fresh content is loading Indicating that the content is stale Deferring re-rendering for a part of the UI Reference useDeferredValue(value, initialValue ) Call useDeferredValue at the top level of your component to get a deferred version of that value",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": "import { useState, useDeferredValue } from 'react';function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // } See more examples below Parameters value: The value you want to defer It can have any type optional initialValue: A value to use during the initial render of a component If this option is omitted, useDeferredValue will not defer during the initial render, because theres no previous version of value that it can render instead",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": "Returns currentValue: During the initial render, the returned deferred value will be the initialValue, or the same as the value you provided During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value)",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Caveats When an update is inside a Transition, useDeferredValue always returns the new value and does not spawn a deferred render, since the update is already deferred The values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "When useDeferredValue receives a different value (compared with Object is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value The background re-render is interruptible: if theres another update to the value, React will restart the background re-render from scratch",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing useDeferredValue is integrated with Suspense If the background update caused by a new value suspends the UI, the user will not see the fallback They will see the old deferred value until the data loads useDeferredValue does not by itself prevent extra network requests There is no fixed delay caused by useDeferredValue itself",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it The background re-render caused by useDeferredValue does not fire Effects until its committed to the screen If the background re-render suspends, its Effects will run after the data loads and the UI updates",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "Usage Showing stale content while fresh content is loading Call useDeferredValue at the top level of your component to defer updating some part of your UI import { useState, useDeferredValue } from 'react';function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // } During the initial render, the deferred value will be the same as the value you provided During updates, the deferred value will lag behind the latest value",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background Lets walk through an example to see when this is useful NoteThis example assumes you use a Suspense-enabled data source: Data fetching with Suspense-enabled frameworks like Relay and Next js Lazy-loading component code with lazy Reading the value of a Promise with use Learn more about Suspense and its limitations",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "In this example, the SearchResults component suspends while fetching the search results Try typing \"a\", waiting for the results, and then editing it to \"ab\" The results for \"a\" get replaced by the loading fallback App jsSearchResults jsApp js ResetForkimport { Suspense, useState } from 'react'; import SearchResults from ' /SearchResults js'; export default function App() { const [query, setQuery] = useState(''); return (  label Search albums: input value={query} onChange={e = setQuery(e target",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "value)} / /label Suspense fallback={h2Loading /h2} SearchResults query={query} / /Suspense / ); } Show more A common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "Call useDeferredValue to pass a deferred version of the query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e target value)} / /label Suspense fallback={h2Loading /h2} SearchResults query={deferredQuery} / /Suspense / );} The query will update immediately, so the input will display the new value",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit Enter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\" Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded: App jsSearchResults jsApp js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from ' /SearchResults",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e target value)} / /label Suspense fallback={h2Loading /h2} SearchResults query={deferredQuery} / /Suspense / ); } Show more Deep DiveHow does deferring a value work under the hood",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "Show DetailsYou can think of it as happening in two steps: First, React re-renders with the new query (\"ab\") but with the old deferredQuery (still \"a\") The deferredQuery value, which you pass to the result list, is deferred: it lags behind the query value In the background, React tries to re-render with both query and deferredQuery updated to \"ab\" If this re-render completes, React will show it on the screen",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "However, if it suspends (the results for \"ab\" have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded The user will keep seeing the stale deferred value until the data is ready The deferred background rendering is interruptible For example, if you type into the input again, React will abandon it and restart with the new value React will always use the latest provided value",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "Note that there is still a network request per each keystroke Whats being deferred here is displaying results (until theyre ready), not the network requests themselves Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesnt fetch again Indicating that the content is stale In the example above, there is no indication that the result list for the latest query is still loading",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "This can be confusing to the user if the new results take a while to load To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed: div style={{ opacity: query == deferredQuery 0 5 : 1,}} SearchResults query={deferredQuery} //div With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below: App jsSearchResults jsApp js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from ' /SearchResults js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query == deferredQuery; return (  label Search albums: input value={query} onChange={e = setQuery(e target",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "value)} / /label Suspense fallback={h2Loading /h2} div style={{ opacity: isStale 0 5 : 1, transition: isStale 'opacity 0 2s 0 2s linear' : 'opacity 0s 0s linear' }} SearchResults query={deferredQuery} / /div /Suspense / ); } Show more Deferring re-rendering for a part of the UI You can also apply useDeferredValue as a performance optimization It is useful when a part of your UI is slow to re-render, theres no easy way to optimize it, and you want to prevent it from blocking the rest of the UI",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke: function App() { const [text, setText] = useState(''); return (  input value={text} onChange={e = setText(e target value)} / SlowList text={text} / / );} First, optimize SlowList to skip re-rendering when its props are the same To do this, wrap it in memo: const SlowList = memo(function SlowList({ text }) { //",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "}); However, this only helps if the SlowList props are the same as during the previous render The problem youre facing now is that its slow when theyre different, and when you actually need to show different visual output Concretely, the main performance problem is that whenever you type into the input, the SlowList receives new props, and re-rendering its entire tree makes the typing feel janky",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "In this case, useDeferredValue lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower): function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return (  input value={text} onChange={e = setText(e target value)} / SlowList text={deferredText} / / );} This does not make re-rendering of the SlowList faster",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "However, it tells React that re-rendering the list can be deprioritized so that it doesnt block the keystrokes The list will lag behind the input and then catch up Like before, React will attempt to update the list as soon as possible, but will not block the user from typing The difference between useDeferredValue and unoptimized re-rendering1 Deferred re-rendering of the list 2",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "Unoptimized re-rendering of the list Example 1 of 2: Deferred re-rendering of the list In this example, each item in the SlowList component is artificially slowed down so that you can see how useDeferredValue lets you keep the input responsive Type into the input and notice that typing feels snappy while the list lags behind it App jsSlowList jsApp js ResetForkimport { useState, useDeferredValue } from 'react'; import SlowList from ' /SlowList",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "js'; export default function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return (  input value={text} onChange={e = setText(e target value)} / SlowList text={deferredText} / / ); } Next Example PitfallThis optimization requires SlowList to be wrapped in memo This is because whenever the text changes, React needs to be able to re-render the parent component quickly",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "During that re-render, deferredText still has its previous value, so SlowList is able to skip re-rendering (its props have not changed) Without memo, it would have to re-render anyway, defeating the point of the optimization Deep DiveHow is deferring a value different from debouncing and throttling Show DetailsThere are two common optimization techniques you might have used before in this scenario: Debouncing means youd wait for the user to stop typing (e g for a second) before updating the list",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "Throttling means youd update the list every once in a while (e g at most once a second) While these techniques are helpful in some cases, useDeferredValue is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the users device Unlike debouncing or throttling, it doesnt require choosing any fixed delay If the users device is fast (e g powerful laptop), the deferred re-render would happen almost immediately and wouldnt be noticeable",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "If the users device is slow, the list would lag behind the input proportionally to how slow the device is Also, unlike with debouncing or throttling, deferred re-renders done by useDeferredValue are interruptible by default This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "By contrast, debouncing and throttling still produce a janky experience because theyre blocking: they merely postpone the moment when rendering blocks the keystroke If the work youre optimizing doesnt happen during rendering, debouncing and throttling are still useful For example, they can let you fire fewer network requests You can also use these techniques together PrevioususeDebugValueNextuseEffectCopyright  Meta Platforms, Incno uwu plzuwu",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useDeferredValue",
          "library": "react",
          "chunk_id": "react_30"
        }
      ],
      "library": "react"
    },
    {
      "url": "https://react.dev/reference/react/useEffect",
      "title": "useEffect \u2013 React",
      "content": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system.useEffect(setup, dependencies?) Reference useEffect(setup, dependencies?) Usage Connecting to an external system Wrapping Effects in custom Hooks Controlling a non-React widget Fetching data with Effects Specifying reactive dependencies Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect Displaying different content on the server and the client Troubleshooting My Effect runs twice when the component mounts My Effect runs after every re-render My Effect keeps re-running in an infinite cycle My cleanup logic runs even though my component didnt unmount My Effect does something visual, and I see a flicker before it runs Reference useEffect(setup, dependencies?) Call useEffect at the top level of your component to declare an Effect: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} See more examples below. Parameters setup: The function with your Effects logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all. Returns useEffect returns undefined. Caveats useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. If youre not trying to synchronize with some external system, you probably dont need an Effect. When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic mirrors your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. If your Effect wasnt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect. If your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information. Even if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect. Effects only run on the client. They dont run during server rendering. Usage Connecting to an external system Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems arent controlled by React, so they are called external. To connect your component to some external system, call useEffect at the top level of your component: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} You need to pass two arguments to useEffect: A setup function with setup code that connects to that system. It should return a cleanup function with cleanup code that disconnects from that system. A list of dependencies including every value from your component used inside of those functions. React calls your setup and cleanup functions whenever its necessary, which may happen multiple times: Your setup code runs when your component is added to the page (mounts). After every re-render of your component where the dependencies have changed: First, your cleanup code runs with the old props and state. Then, your setup code runs with the new props and state. Your cleanup code runs one final time after your component is removed from the page (unmounts). Lets illustrate this sequence for the example above. When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time. To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). See common solutions. Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldnt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly mirrors the setup logic, your Effect is resilient to running setup and cleanup as often as needed. NoteAn Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code thats not controlled by React, such as: A timer managed with setInterval() and clearInterval(). An event subscription using window.addEventListener() and window.removeEventListener(). A third-party animation library with an API like animation.start() and animation.reset(). If youre not connecting to any external system, you probably dont need an Effect. Examples of connecting to an external system1. Connecting to a chat server 2. Listening to a global browser event 3. Triggering an animation 4. Controlling a modal dialog 5. Tracking element visibility Example 1 of 5: Connecting to a chat server In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press Open chat to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press Close chat to see the Effect disconnect one last time.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [roomId, serverUrl]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show  hr /} {show  ChatRoom roomId={roomId} /} / ); } Show moreNext Example Wrapping Effects in custom Hooks Effects are an escape hatch: you use them when you need to step outside React and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, its usually a sign that you need to extract some custom Hooks for common behaviors your components rely on. For example, this useChatRoom custom Hook hides the logic of your Effect behind a more declarative API: function useChatRoom({ serverUrl, roomId }) { useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId, serverUrl]);} Then you can use it from any component like this: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); // ... There are also many excellent custom Hooks for every purpose available in the React ecosystem. Learn more about wrapping Effects in custom Hooks. Examples of wrapping Effects in custom Hooks1. Custom useChatRoom Hook 2. Custom useWindowListener Hook 3. Custom useIntersectionObserver Hook Example 1 of 3: Custom useChatRoom Hook This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.App.jsuseChatRoom.jschat.jsApp.js ResetForkimport { useState } from 'react'; import { useChatRoom } from './useChatRoom.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show  hr /} {show  ChatRoom roomId={roomId} /} / ); } Show moreNext Example Controlling a non-React widget Sometimes, you want to keep an external system synchronized to some prop or state of your component. For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized: App.jsMap.jsmap-widget.jsMap.js ResetForkimport { useRef, useEffect } from 'react'; import { MapWidget } from './map-widget.js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() = { if (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return ( div style={{ width: 200, height: 200 }} ref={containerRef} / ); } Show more In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine. Fetching data with Effects You can use an Effect to fetch data for your component. Note that if you use a framework, using your frameworks data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; }; }, [person]); // ... Note the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesnt suffer from race conditions: network responses may arrive in a different order than you sent them. App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more You can also rewrite using the async / await syntax, but you still need to provide a cleanup function: App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { async function startFetching() { setBio(null); const result = await fetchBio(person); if (!ignore) { setBio(result); } } let ignore = false; startFetching(); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. Its easier to use a custom Hookeither your own or maintained by the community. Deep DiveWhat are good alternatives to data fetching in Effects? Show DetailsWriting fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides: Effects dont run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient. Fetching directly in Effects makes it easy to create network waterfalls. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel. Fetching directly in Effects usually means you dont preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again. Its not very ergonomic. Theres quite a bit of boilerplate code involved when writing fetch calls in a way that doesnt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches: If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and dont suffer from the above pitfalls. Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Specifying reactive dependencies Notice that you cant choose the dependencies of your Effect. Every reactive value used by your Effects code must be declared as a dependency. Your Effects dependency list is determined by the surrounding code: function ChatRoom({ roomId }) { // This is a reactive value const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too useEffect(() = { const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values connection.connect(); return () = connection.disconnect(); }, [serverUrl, roomId]); //  So you must specify them as dependencies of your Effect // ...} If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you cant remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl' // ...} To remove a dependency, you need to prove to the linter that it doesnt need to be a dependency. For example, you can move serverUrl out of your component to prove that its not reactive and wont change on re-renders: const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  All dependencies declared // ...} Now that serverUrl is not a reactive value (and cant change on a re-render), it doesnt need to be a dependency. If your Effects code doesnt use any reactive values, its dependency list should be empty ([]): const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  All dependencies declared // ...} An Effect with empty dependencies doesnt re-run when any of your components props or state change. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() = { // ... //  Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies dont match the code, there is a high risk of introducing bugs. By suppressing the linter, you lie to React about the values your Effect depends on. Instead, prove theyre unnecessary. Examples of passing reactive dependencies1. Passing a dependency array 2. Passing an empty dependency array 3. Passing no dependency array at all Example 1 of 3: Passing a dependency array If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.useEffect(() = { // ...}, [a, b]); // Runs again if a or b are differentIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isnt used in the Effect (and so it isnt a dependency), editing the message doesnt re-connect to the chat.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 label Your message:{' '} input value={message} onChange={e = setMessage(e.target.value)} / /label / ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button /label {show  hr /} {show  ChatRoom roomId={roomId}/} / ); } Show moreNext Example Updating state based on previous state from an Effect When you want to update state based on previous state from an Effect, you might run into a problem: function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(count + 1); // You want to increment the counter every second... }, 1000) return () = clearInterval(intervalId); }, [count]); //  ... but specifying `count` as a dependency always resets the interval. // ...} Since count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal. To fix this, pass the c = c + 1 state updater to setCount: App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(c = c + 1); //  Pass a state updater }, 1000); return () = clearInterval(intervalId); }, []); //  Now count is not a dependency return h1{count}/h1; } Now that youre passing c = c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it wont need to cleanup and setup the interval again every time the count changes. Removing unnecessary object dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { //  This object is created from scratch on every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() = { const connection = createConnection(options); // It's used inside the Effect connection.connect(); return () = connection.disconnect(); }, [options]); //  As a result, these dependencies are always different on a re-render // ... Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike an object which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Removing unnecessary function dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { //  This function is created from scratch on every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() = { const options = createOptions(); // It's used inside the Effect const connection = createConnection(); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  As a result, these dependencies are always different on a re-render // ... By itself, creating a function from scratch on every re-render is not a problem. You dont need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike a function which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Reading the latest props and state from an Effect Under ConstructionThis section describes an experimental API that has not yet been released in a stable version of React. By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect reacts to every change of that value. For most dependencies, thats the behavior you want. However, sometimes youll want to read the latest props and state from an Effect without reacting to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit: function Page({ url, shoppingCart }) { useEffect(() = { logVisit(url, shoppingCart.length); }, [url, shoppingCart]); //  All dependencies declared // ...} What if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You cant exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you dont want a piece of code to react to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it: function Page({ url, shoppingCart }) { const onVisit = useEffectEvent(visitedUrl = { logVisit(visitedUrl, shoppingCart.length) }); useEffect(() = { onVisit(url); }, [url]); //  All dependencies declared // ...} Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart wont re-run your Effect. Read more about how Effect Events let you separate reactive and non-reactive code. Displaying different content on the server and the client If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server. In rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it cant possibly do that on the server. Here is how you could implement this: function MyComponent() { const [didMount, setDidMount] = useState(false); useEffect(() = { setDidMount(true); }, []); if (didMount) { // ... return client-only JSX ... } else { // ... return initial JSX ... }} While the app is loading, the user will see the initial render output. Then, when its loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects dont run on the server, so this is why didMount was false during the initial server render. Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of timepotentially, many secondsso you dont want to make jarring changes to your components appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS. Troubleshooting My Effect runs twice when the component mounts When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). Read more about how this helps find bugs and how to fix your logic. My Effect runs after every re-render First, check that you havent forgotten to specify the dependency array: useEffect(() = { // ...}); //  No dependency array: re-runs after every render! If youve specified the dependency array but your Effect still re-runs in a loop, its because one of your dependencies is different on every re-render. You can debug this problem by manually logging your dependencies to the console: useEffect(() = { // .. }, [serverUrl, roomId]); console.log([serverUrl, roomId]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect As a last resort (if these methods didnt help), wrap its creation with useMemo or useCallback (for functions). My Effect keeps re-running in an infinite cycle If your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state. That state leads to a re-render, which causes the Effects dependencies to change. Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your applications data flow with it? If there is no external system, consider whether removing the Effect altogether would simplify your logic. If youre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your components visual output? If you need to keep track of some data that isnt used by rendering, a ref (which doesnt trigger re-renders) might be more appropriate. Verify your Effect doesnt update the state (and trigger re-renders) more than needed. Finally, if your Effect is updating the state at the right time, but there is still a loop, its because that state update leads to one of the Effects dependencies changing. Read how to debug dependency changes. My cleanup logic runs even though my component didnt unmount The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts. If you have cleanup code without corresponding setup code, its usually a code smell: useEffect(() = { //  Avoid: Cleanup logic without corresponding setup logic return () = { doSomething(); };}, []); Your cleanup logic should be symmetrical to the setup logic, and should stop or undo whatever setup did: useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); Learn how the Effect lifecycle is different from the components lifecycle. My Effect does something visual, and I see a flicker before it runs If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldnt be needed for the vast majority of Effects. Youll only need this if its crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.PrevioususeDeferredValueNextuseIdCopyright  Meta Platforms, Incno uwu plzuwu?Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
      "code_blocks": [
        "useEffect(setup, dependencies?)",
        "useEffect(setup, dependencies?)",
        "useEffect(setup, dependencies?)",
        "useEffect(setup, dependencies?)",
        "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}",
        "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}",
        "dependencies",
        "[dep1, dep2, dep3]",
        "useLayoutEffect",
        "useLayoutEffect",
        "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}",
        "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}",
        "setInterval()",
        "clearInterval()",
        "window.addEventListener()",
        "window.removeEventListener()",
        "animation.start()",
        "animation.reset()",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}",
        "useChatRoom",
        "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}",
        "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}",
        "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ...",
        "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ...",
        "useChatRoom",
        "useWindowListener",
        "useIntersectionObserver",
        "useChatRoom",
        "import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}",
        "map-widget.js",
        "import { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      mapRef.current = new MapWidget(containerRef.current);\n    }\n\n    const map = mapRef.current;\n    map.setZoom(zoomLevel);\n  }, [zoomLevel]);\n\n  return (\n    <div\n      style={{ width: 200, height: 200 }}\n      ref={containerRef}\n    />\n  );\n}",
        "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ...",
        "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ...",
        "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    let ignore = false;\n    setBio(null);\n    fetchBio(person).then(result => {\n      if (!ignore) {\n        setBio(result);\n      }\n    });\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}",
        "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    async function startFetching() {\n      setBio(null);\n      const result = await fetchBio(person);\n      if (!ignore) {\n        setBio(result);\n      }\n    }\n\n    let ignore = false;\n    startFetching();\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}",
        "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // \u2705 So you must specify them as dependencies of your Effect  // ...}",
        "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // \u2705 So you must specify them as dependencies of your Effect  // ...}",
        "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // \ud83d\udd34 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}",
        "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // \ud83d\udd34 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}",
        "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // \u2705 All dependencies declared  // ...}",
        "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // \u2705 All dependencies declared  // ...}",
        "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // \u2705 All dependencies declared  // ...}",
        "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // \u2705 All dependencies declared  // ...}",
        "useEffect(() => {  // ...  // \ud83d\udd34 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);",
        "useEffect(() => {  // ...  // \ud83d\udd34 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);",
        "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different",
        "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [serverUrl, roomId]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n      <label>\n        Your message:{' '}\n        <input value={message} onChange={e => setMessage(e.target.value)} />\n      </label>\n    </>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n        <button onClick={() => setShow(!show)}>\n          {show ? 'Close chat' : 'Open chat'}\n        </button>\n      </label>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId}/>}\n    </>\n  );\n}",
        "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // \ud83d\udea9 ... but specifying `count` as a dependency always resets the interval.  // ...}",
        "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // \ud83d\udea9 ... but specifying `count` as a dependency always resets the interval.  // ...}",
        "import { useState, useEffect } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(c => c + 1); // \u2705 Pass a state updater\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []); // \u2705 Now count is not a dependency\n\n  return <h1>{count}</h1>;\n}",
        "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // \ud83d\udea9 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render  // ...",
        "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // \ud83d\udea9 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render  // ...",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}",
        "createOptions",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // \ud83d\udea9 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render  // ...",
        "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // \ud83d\udea9 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render  // ...",
        "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}",
        "createOptions",
        "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // \u2705 All dependencies declared  // ...}",
        "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // \u2705 All dependencies declared  // ...}",
        "shoppingCart",
        "shoppingCart",
        "useEffectEvent",
        "shoppingCart",
        "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // \u2705 All dependencies declared  // ...}",
        "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // \u2705 All dependencies declared  // ...}",
        "shoppingCart",
        "shoppingCart",
        "localStorage",
        "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}",
        "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}",
        "useEffect(() => {  // ...}); // \ud83d\udea9 No dependency array: re-runs after every render!",
        "useEffect(() => {  // ...}); // \ud83d\udea9 No dependency array: re-runs after every render!",
        "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);",
        "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);",
        "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...",
        "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...",
        "useCallback",
        "useEffect(() => {  // \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);",
        "useEffect(() => {  // \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);",
        "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);",
        "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);",
        "useLayoutEffect"
      ],
      "chunks": [
        {
          "content": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system useEffect(setup, dependencies ) Reference useEffect(setup, dependencies",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_0"
        },
        {
          "content": ") Usage Connecting to an external system Wrapping Effects in custom Hooks Controlling a non-React widget Fetching data with Effects Specifying reactive dependencies Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect Displaying different content on the server and the client Troubleshooting My Effect runs twice when the component mounts My Effect runs after every re-render My Effect keeps re-running in an infinite cycle My cleanup logic runs even though my component didnt unmount My Effect does something visual, and I see a flicker before it runs Reference useEffect(setup, dependencies",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_1"
        },
        {
          "content": ") Call useEffect at the top level of your component to declare an Effect: import { useState, useEffect } from 'react';import { createConnection } from ' /chat js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = { connection disconnect(); }; }, [serverUrl, roomId]); // } See more examples below",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_2"
        },
        {
          "content": "Parameters setup: The function with your Effects logic Your setup function may also optionally return a cleanup function When your component is added to the DOM, React will run your setup function After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values After your component is removed from the DOM, React will run your cleanup function",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_3"
        },
        {
          "content": "optional dependencies: The list of all reactive values referenced inside of the setup code Reactive values include props, state, and all the variables and functions declared directly inside your component body If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_4"
        },
        {
          "content": "React will compare each dependency with its previous value using the Object is comparison If you omit this argument, your Effect will re-run after every re-render of the component See the difference between passing an array of dependencies, an empty array, and no dependencies at all Returns useEffect returns undefined Caveats useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks You cant call it inside loops or conditions",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_5"
        },
        {
          "content": "If you need that, extract a new component and move the state into it If youre not trying to synchronize with some external system, you probably dont need an Effect When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup This is a stress-test that ensures that your cleanup logic mirrors your setup logic and that it stops or undoes whatever the setup is doing If this causes a problem, implement the cleanup function",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_6"
        },
        {
          "content": "If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed To fix this, remove unnecessary object and function dependencies You can also extract state updates and non-reactive logic outside of your Effect If your Effect wasnt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_7"
        },
        {
          "content": "If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect If your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen This ensures that the result of the Effect can be observed by the event system Usually, this works as expected",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_8"
        },
        {
          "content": "However, if you must defer the work until after paint, such as an alert(), you can use setTimeout See reactwg/react-18/128 for more information Even if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect Usually, this works as expected However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect Effects only run on the client",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_9"
        },
        {
          "content": "They dont run during server rendering Usage Connecting to an external system Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page These systems arent controlled by React, so they are called external To connect your component to some external system, call useEffect at the top level of your component: import { useState, useEffect } from 'react';import { createConnection } from ' /chat",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_10"
        },
        {
          "content": "js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = { connection disconnect(); }; }, [serverUrl, roomId]); // } You need to pass two arguments to useEffect: A setup function with setup code that connects to that system It should return a cleanup function with cleanup code that disconnects from that system",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_11"
        },
        {
          "content": "A list of dependencies including every value from your component used inside of those functions React calls your setup and cleanup functions whenever its necessary, which may happen multiple times: Your setup code runs when your component is added to the page (mounts) After every re-render of your component where the dependencies have changed: First, your cleanup code runs with the old props and state Then, your setup code runs with the new props and state",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_12"
        },
        {
          "content": "Your cleanup code runs one final time after your component is removed from the page (unmounts) Lets illustrate this sequence for the example above When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_13"
        },
        {
          "content": "When the ChatRoom component is removed from the page, your Effect will disconnect one last time To help you find bugs, in development React runs setup and cleanup one extra time before the setup This is a stress-test that verifies your Effects logic is implemented correctly If this causes visible issues, your cleanup function is missing some logic The cleanup function should stop or undo whatever the setup function was doing",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_14"
        },
        {
          "content": "The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development) See common solutions Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time It shouldnt matter whether your component is mounting, updating, or unmounting",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_15"
        },
        {
          "content": "When your cleanup logic correctly mirrors the setup logic, your Effect is resilient to running setup and cleanup as often as needed NoteAn Effect lets you keep your component synchronized with some external system (like a chat service) Here, external system means any piece of code thats not controlled by React, such as: A timer managed with setInterval() and clearInterval() An event subscription using window addEventListener() and window removeEventListener()",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_16"
        },
        {
          "content": "A third-party animation library with an API like animation start() and animation reset() If youre not connecting to any external system, you probably dont need an Effect Examples of connecting to an external system1 Connecting to a chat server 2 Listening to a global browser event 3 Triggering an animation 4 Controlling a modal dialog 5",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_17"
        },
        {
          "content": "Tracking element visibility Example 1 of 5: Connecting to a chat server In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat js Press Open chat to make the ChatRoom component appear This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_18"
        },
        {
          "content": "Press Close chat to see the Effect disconnect one last time App jschat jsApp js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from ' /chat js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = { connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_19"
        },
        {
          "content": "disconnect(); }; }, [roomId, serverUrl]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e target value)} / /label h1Welcome to the {roomId} room /h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e target",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_20"
        },
        {
          "content": "value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow( show)} {show 'Close chat' : 'Open chat'} /button {show  hr /} {show  ChatRoom roomId={roomId} /} / ); } Show moreNext Example Wrapping Effects in custom Hooks Effects are an escape hatch: you use them when you need to step outside React and when there is no better built-in solution for your use case",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_21"
        },
        {
          "content": "If you find yourself often needing to manually write Effects, its usually a sign that you need to extract some custom Hooks for common behaviors your components rely on For example, this useChatRoom custom Hook hides the logic of your Effect behind a more declarative API: function useChatRoom({ serverUrl, roomId }) { useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_22"
        },
        {
          "content": "disconnect(); }, [roomId, serverUrl]);} Then you can use it from any component like this: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); // There are also many excellent custom Hooks for every purpose available in the React ecosystem Learn more about wrapping Effects in custom Hooks Examples of wrapping Effects in custom Hooks1 Custom useChatRoom Hook 2 Custom useWindowListener Hook 3",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_23"
        },
        {
          "content": "Custom useIntersectionObserver Hook Example 1 of 3: Custom useChatRoom Hook This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook App jsuseChatRoom jschat jsApp js ResetForkimport { useState } from 'react'; import { useChatRoom } from ' /useChatRoom",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_24"
        },
        {
          "content": "js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e target value)} / /label h1Welcome to the {roomId} room",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_25"
        },
        {
          "content": "/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e target value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow( show)} {show",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_26"
        },
        {
          "content": "'Close chat' : 'Open chat'} /button {show  hr /} {show  ChatRoom roomId={roomId} /} / ); } Show moreNext Example Controlling a non-React widget Sometimes, you want to keep an external system synchronized to some prop or state of your component For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_27"
        },
        {
          "content": "This Effect creates an instance of a MapWidget class defined in map-widget js When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized: App jsMap jsmap-widget jsMap js ResetForkimport { useRef, useEffect } from 'react'; import { MapWidget } from ' /map-widget js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() = { if (mapRef",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_28"
        },
        {
          "content": "current === null) { mapRef current = new MapWidget(containerRef current); } const map = mapRef current; map setZoom(zoomLevel); }, [zoomLevel]); return ( div style={{ width: 200, height: 200 }} ref={containerRef} / ); } Show more In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_29"
        },
        {
          "content": "After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine Fetching data with Effects You can use an Effect to fetch data for your component Note that if you use a framework, using your frameworks data fetching mechanism will be a lot more efficient than writing Effects manually",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_30"
        },
        {
          "content": "If you want to fetch data from an Effect manually, your code might look like this: import { useState, useEffect } from 'react';import { fetchBio } from ' /api js';export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person) then(result = { if ( ignore) { setBio(result); } }); return () = { ignore = true; }; }, [person]); //",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_31"
        },
        {
          "content": "Note the ignore variable which is initialized to false, and is set to true during cleanup This ensures your code doesnt suffer from race conditions: network responses may arrive in a different order than you sent them App jsApp js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from ' /api",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_32"
        },
        {
          "content": "js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person) then(result = { if ( ignore) { setBio(result); } }); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e target value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio 'Loading",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_33"
        },
        {
          "content": "'}/i/p / ); } Show more You can also rewrite using the async / await syntax, but you still need to provide a cleanup function: App jsApp js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from ' /api js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { async function startFetching() { setBio(null); const result = await fetchBio(person); if (",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_34"
        },
        {
          "content": "ignore) { setBio(result); } } let ignore = false; startFetching(); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e target value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio 'Loading '}/i/p / ); } Show more Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_35"
        },
        {
          "content": "Its easier to use a custom Hookeither your own or maintained by the community Deep DiveWhat are good alternatives to data fetching in Effects Show DetailsWriting fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps This is, however, a very manual approach and it has significant downsides: Effects dont run on the server This means that the initial server-rendered HTML will only include a loading state with no data",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_36"
        },
        {
          "content": "The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data This is not very efficient Fetching directly in Effects makes it easy to create network waterfalls You render the parent component, it fetches some data, renders the child components, and then they start fetching their data If the network is not very fast, this is significantly slower than fetching all data in parallel",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_37"
        },
        {
          "content": "Fetching directly in Effects usually means you dont preload or cache data For example, if the component unmounts and then mounts again, it would have to fetch the data again Its not very ergonomic Theres quite a bit of boilerplate code involved when writing fetch calls in a way that doesnt suffer from bugs like race conditions This list of downsides is not specific to React It applies to fetching data on mount with any library",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_38"
        },
        {
          "content": "Like with routing, data fetching is not trivial to do well, so we recommend the following approaches: If you use a framework, use its built-in data fetching mechanism Modern React frameworks have integrated data fetching mechanisms that are efficient and dont suffer from the above pitfalls Otherwise, consider using or building a client-side cache Popular open source solutions include React Query, useSWR, and React Router 6 4+",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_39"
        },
        {
          "content": "You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes) You can continue fetching data directly in Effects if neither of these approaches suit you Specifying reactive dependencies Notice that you cant choose the dependencies of your Effect",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_40"
        },
        {
          "content": "Every reactive value used by your Effects code must be declared as a dependency Your Effects dependency list is determined by the surrounding code: function ChatRoom({ roomId }) { // This is a reactive value const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too useEffect(() = { const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_41"
        },
        {
          "content": "disconnect(); }, [serverUrl, roomId]); //  So you must specify them as dependencies of your Effect // } If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values Reactive values include props and all variables and functions declared directly inside of your component Since roomId and serverUrl are reactive values, you cant remove them from the dependencies",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_42"
        },
        {
          "content": "If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = connection disconnect(); }, []); //  React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl' //",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_43"
        },
        {
          "content": "} To remove a dependency, you need to prove to the linter that it doesnt need to be a dependency For example, you can move serverUrl out of your component to prove that its not reactive and wont change on re-renders: const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_44"
        },
        {
          "content": "disconnect(); }, [roomId]); //  All dependencies declared // } Now that serverUrl is not a reactive value (and cant change on a re-render), it doesnt need to be a dependency",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_45"
        },
        {
          "content": "If your Effects code doesnt use any reactive values, its dependency list should be empty ([]): const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = connection disconnect(); }, []); //  All dependencies declared //",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_46"
        },
        {
          "content": "} An Effect with empty dependencies doesnt re-run when any of your components props or state change PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() = { // //  Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies dont match the code, there is a high risk of introducing bugs By suppressing the linter, you lie to React about the values your Effect depends on",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_47"
        },
        {
          "content": "Instead, prove theyre unnecessary Examples of passing reactive dependencies1 Passing a dependency array 2 Passing an empty dependency array 3 Passing no dependency array at all Example 1 of 3: Passing a dependency array If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies useEffect(() = { //",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_48"
        },
        {
          "content": "}, [a, b]); // Runs again if a or b are differentIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect However, since message isnt used in the Effect (and so it isnt a dependency), editing the message doesnt re-connect to the chat App jschat jsApp",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_49"
        },
        {
          "content": "js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from ' /chat js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = { connection disconnect(); }; }, [serverUrl, roomId]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_50"
        },
        {
          "content": "target value)} / /label h1Welcome to the {roomId} room /h1 label Your message:{' '} input value={message} onChange={e = setMessage(e target value)} / /label / ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e target",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_51"
        },
        {
          "content": "value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select button onClick={() = setShow( show)} {show",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_52"
        },
        {
          "content": "'Close chat' : 'Open chat'} /button /label {show  hr /} {show  ChatRoom roomId={roomId}/} / ); } Show moreNext Example Updating state based on previous state from an Effect When you want to update state based on previous state from an Effect, you might run into a problem: function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(count + 1); // You want to increment the counter every second",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_53"
        },
        {
          "content": "}, 1000) return () = clearInterval(intervalId); }, [count]); // but specifying `count` as a dependency always resets the interval // } Since count is a reactive value, it must be specified in the list of dependencies However, that causes the Effect to cleanup and setup again every time the count changes This is not ideal To fix this, pass the c = c + 1 state updater to setCount: App jsApp",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_54"
        },
        {
          "content": "js ResetForkimport { useState, useEffect } from 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(c = c + 1); //  Pass a state updater }, 1000); return () = clearInterval(intervalId); }, []); //  Now count is not a dependency return h1{count}/h1; } Now that youre passing c = c + 1 instead of count + 1, your Effect no longer needs to depend on count",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_55"
        },
        {
          "content": "As a result of this fix, it wont need to cleanup and setup the interval again every time the count changes Removing unnecessary object dependencies If your Effect depends on an object or a function created during rendering, it might run too often",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_56"
        },
        {
          "content": "For example, this Effect re-connects after every render because the options object is different for every render: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { //  This object is created from scratch on every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() = { const connection = createConnection(options); // It's used inside the Effect connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_57"
        },
        {
          "content": "disconnect(); }, [options]); //  As a result, these dependencies are always different on a re-render // Avoid using an object created during rendering as a dependency Instead, create the object inside the Effect: App jschat jsApp js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from ' /chat",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_58"
        },
        {
          "content": "js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection connect(); return () = connection disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room /h1 input value={message} onChange={e = setMessage(e target",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_59"
        },
        {
          "content": "value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e target value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_60"
        },
        {
          "content": "With this fix, typing into the input doesnt reconnect the chat Unlike an object which gets re-created, a string like roomId doesnt change unless you set it to another value Read more about removing dependencies Removing unnecessary function dependencies If your Effect depends on an object or a function created during rendering, it might run too often",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_61"
        },
        {
          "content": "For example, this Effect re-connects after every render because the createOptions function is different for every render: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { //  This function is created from scratch on every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() = { const options = createOptions(); // It's used inside the Effect const connection = createConnection(); connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_62"
        },
        {
          "content": "disconnect(); }, [createOptions]); //  As a result, these dependencies are always different on a re-render // By itself, creating a function from scratch on every re-render is not a problem You dont need to optimize that However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render Avoid using a function created during rendering as a dependency Instead, declare it inside the Effect: App jschat jsApp",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_63"
        },
        {
          "content": "js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from ' /chat js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection connect(); return () = connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_64"
        },
        {
          "content": "disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room /h1 input value={message} onChange={e = setMessage(e target value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e target",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_65"
        },
        {
          "content": "value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string With this fix, typing into the input doesnt reconnect the chat Unlike a function which gets re-created, a string like roomId doesnt change unless you set it to another value",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_66"
        },
        {
          "content": "Read more about removing dependencies Reading the latest props and state from an Effect Under ConstructionThis section describes an experimental API that has not yet been released in a stable version of React By default, when you read a reactive value from an Effect, you have to add it as a dependency This ensures that your Effect reacts to every change of that value For most dependencies, thats the behavior you want",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_67"
        },
        {
          "content": "However, sometimes youll want to read the latest props and state from an Effect without reacting to them For example, imagine you want to log the number of the items in the shopping cart for every page visit: function Page({ url, shoppingCart }) { useEffect(() = { logVisit(url, shoppingCart length); }, [url, shoppingCart]); //  All dependencies declared // } What if you want to log a new page visit after every url change, but not if only the shoppingCart changes",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_68"
        },
        {
          "content": "You cant exclude shoppingCart from dependencies without breaking the reactivity rules However, you can express that you dont want a piece of code to react to changes even though it is called from inside an Effect Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it: function Page({ url, shoppingCart }) { const onVisit = useEffectEvent(visitedUrl = { logVisit(visitedUrl, shoppingCart",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_69"
        },
        {
          "content": "length) }); useEffect(() = { onVisit(url); }, [url]); //  All dependencies declared // } Effect Events are not reactive and must always be omitted from dependencies of your Effect This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them By reading shoppingCart inside of onVisit, you ensure that shoppingCart wont re-run your Effect Read more about how Effect Events let you separate reactive and non-reactive code",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_70"
        },
        {
          "content": "Displaying different content on the server and the client If your app uses server rendering (either directly or via a framework), your component will render in two different environments On the server, it will render to produce the initial HTML On the client, React will run the rendering code again so that it can attach your event handlers to that HTML This is why, for hydration to work, your initial render output must be identical on the client and the server",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_71"
        },
        {
          "content": "In rare cases, you might need to display different content on the client For example, if your app reads some data from localStorage, it cant possibly do that on the server Here is how you could implement this: function MyComponent() { const [didMount, setDidMount] = useState(false); useEffect(() = { setDidMount(true); }, []); if (didMount) { // return client-only JSX } else { // return initial JSX }} While the app is loading, the user will see the initial render output",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_72"
        },
        {
          "content": "Then, when its loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render This will switch to the client-only render output Effects dont run on the server, so this is why didMount was false during the initial server render Use this pattern sparingly Keep in mind that users with a slow connection will see the initial content for quite a bit of timepotentially, many secondsso you dont want to make jarring changes to your components appearance",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_73"
        },
        {
          "content": "In many cases, you can avoid the need for this by conditionally showing different things with CSS Troubleshooting My Effect runs twice when the component mounts When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup This is a stress-test that verifies your Effects logic is implemented correctly If this causes visible issues, your cleanup function is missing some logic",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_74"
        },
        {
          "content": "The cleanup function should stop or undo whatever the setup function was doing The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development) Read more about how this helps find bugs and how to fix your logic My Effect runs after every re-render First, check that you havent forgotten to specify the dependency array: useEffect(() = { //",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_75"
        },
        {
          "content": "}); //  No dependency array: re-runs after every render If youve specified the dependency array but your Effect still re-runs in a loop, its because one of your dependencies is different on every re-render You can debug this problem by manually logging your dependencies to the console: useEffect(() = { // }, [serverUrl, roomId]); console log([serverUrl, roomId]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_76"
        },
        {
          "content": "Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays Object is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays Object is(temp1[2], temp2[2]); // and so on for every dependency",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_77"
        },
        {
          "content": "When you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect As a last resort (if these methods didnt help), wrap its creation with useMemo or useCallback (for functions)",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_78"
        },
        {
          "content": "My Effect keeps re-running in an infinite cycle If your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state That state leads to a re-render, which causes the Effects dependencies to change Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on) Why does your Effect need to set state Does it synchronize with that external system",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_79"
        },
        {
          "content": "Or are you trying to manage your applications data flow with it If there is no external system, consider whether removing the Effect altogether would simplify your logic If youre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state Has something changed that affects your components visual output",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_80"
        },
        {
          "content": "If you need to keep track of some data that isnt used by rendering, a ref (which doesnt trigger re-renders) might be more appropriate Verify your Effect doesnt update the state (and trigger re-renders) more than needed Finally, if your Effect is updating the state at the right time, but there is still a loop, its because that state update leads to one of the Effects dependencies changing Read how to debug dependency changes",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_81"
        },
        {
          "content": "My cleanup logic runs even though my component didnt unmount The cleanup function runs not only during unmount, but before every re-render with changed dependencies Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_82"
        },
        {
          "content": "If you have cleanup code without corresponding setup code, its usually a code smell: useEffect(() = { //  Avoid: Cleanup logic without corresponding setup logic return () = { doSomething(); };}, []); Your cleanup logic should be symmetrical to the setup logic, and should stop or undo whatever setup did: useEffect(() = { const connection = createConnection(serverUrl, roomId); connection connect(); return () = { connection",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_83"
        },
        {
          "content": "disconnect(); }; }, [serverUrl, roomId]); Learn how the Effect lifecycle is different from the components lifecycle My Effect does something visual, and I see a flicker before it runs If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect Note that this shouldnt be needed for the vast majority of Effects",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_84"
        },
        {
          "content": "Youll only need this if its crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it PrevioususeDeferredValueNextuseIdCopyright  Meta Platforms, Incno uwu plzuwu Logo bysawaratsuki1004Learn ReactQuick StartInstallationDescribing the UIAdding InteractivityManaging StateEscape HatchesAPI ReferenceReact APIsReact DOM APIsCommunityCode of ConductMeet the TeamDocs ContributorsAcknowledgementsMoreBlogReact NativePrivacyTerms",
          "url": "https://react.dev/reference/react/useEffect",
          "library": "react",
          "chunk_id": "react_85"
        }
      ],
      "library": "react"
    }
  ],
  "scraped_at": 9145.030021458
}